{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Home","text":"<p>Minions is an extensible, MCP-compliant agentic AI framework written in Java and built using idiomatic Spring practices. Designed from the ground up with the principles of extensibility, traceability, and enterprise readiness, Minions provides a solid foundation for building and orchestrating autonomous AI agents in regulated and complex environments.</p> <p>At its core, Minions follows the Open/Closed Principle: the system is open for extension but closed for modification. Whether you're building a ReAct-style reasoning agent, a planner-executor-observer pipeline, or a bespoke recipe for your enterprise workflow, Minions enables it without changing the underlying framework.</p>"},{"location":"index.html#why-minions","title":"Why Minions?","text":"<p>The AI ecosystem has rapidly shifted toward agentic workflows\u2014systems where autonomous agents reason, plan, act, and reflect over multiple steps. While many open-source frameworks offer this in Python, Minions is one of the few that brings this capability to the enterprise Java ecosystem with full support for:</p> <ul> <li>Spring Boot auto-configuration and injection</li> <li>Modular architecture that can be expanded with Spring Beans</li> <li>Privacy and governance by design</li> <li>Idiomatic support for lifecycle management, configuration, and testing</li> </ul>"},{"location":"index.html#key-design-principles","title":"Key Design Principles","text":"<ul> <li> <p>Extensibility First   Minions uses design patterns like Definition/Customizer, Chain of Responsibility, and Factory Registry to allow seamless plug-in of new components\u2014steps, tools, memories, processors\u2014without modifying the core.</p> </li> <li> <p>Idiomatic Spring Integration   The framework follows familiar Spring idioms, making it easy for developers to inject, override, and extend functionality using standard annotations and configuration mechanisms.</p> </li> <li> <p>MCP Compliance   Minions adheres to the Model Connector Protocol (MCP), enabling composability, cross-model interoperability, and architectural clarity.</p> </li> <li> <p>Enterprise-Grade Capabilities   Features like memory privacy, audit hooks, multi-tenant memory isolation, and structured evaluation make Minions a suitable foundation for regulated industries like insurance, healthcare, and finance.</p> </li> </ul>"},{"location":"index.html#agent-recipes","title":"Agent Recipes","text":"<p>Every agent in Minions is instantiated from a Recipe. A recipe defines the agent\u2019s purpose and structure:</p> <ul> <li>Its system prompt and goal</li> <li>The step graph that outlines its thought/action flow</li> <li>Its memory strategy, specifying what the agent remembers and when</li> <li>Optional toolchains and observers</li> </ul> <p>Different types of recipes are available out-of-the-box, including: - <code>ReActAgentRecipe</code> - <code>PlannerExecutorObserverRecipe</code> - And more custom agent types</p> <p>We\u2019ll dive deeper into recipes, step graphs, and memory strategies in the following sections.</p>"},{"location":"01%20-%20Core%20Concepts.html","title":"Core Concepts","text":"<p>Understanding the foundational elements of Minions is essential before diving into its deeper architecture. This section introduces the two most important constructs: Agents and Recipes.</p>"},{"location":"01%20-%20Core%20Concepts.html#what-is-an-agent","title":"What is an Agent?","text":"<p>In Minions, an Agent is an autonomous entity capable of executing a goal-driven process. It engages in multi-step reasoning, decision-making, and tool interaction. Each agent operates within a defined context, maintaining state across steps and coordinating its behavior using recipes, memory, and step graphs.</p>"},{"location":"01%20-%20Core%20Concepts.html#agent-lifecycle","title":"Agent Lifecycle","text":"<ol> <li> <p>Initialization: The agent is instantiated from a recipe. This includes loading its system prompt, goal, memory configuration, and step graph.</p> </li> <li> <p>Goal Assignment: A goal is defined either at instantiation or injected dynamically (e.g., from user input or a higher-level planner).</p> </li> <li> <p>Step Execution: The agent traverses its step graph, making decisions, calling models, and interacting with tools as needed.</p> </li> <li> <p>Memory Update: After each step, the agent records new information, summarizes if needed, and updates relevant memories.</p> </li> <li> <p>Completion: The agent completes once the graph reaches a terminal node or a completion condition is met.</p> </li> </ol> <p>Agents are MCP-compliant and traceable, allowing developers to monitor execution, review decision points, and integrate with observability tooling.</p>"},{"location":"01%20-%20Core%20Concepts.html#what-is-a-recipe","title":"What is a Recipe?","text":"<p>A Recipe is a declarative blueprint for constructing an agent. Rather than configuring agents imperatively through code, developers define recipes that describe the agent\u2019s identity, structure, and behavior.</p> <p>A recipe includes:</p> <ul> <li> <p>System Prompt \u2013 The initial set of instructions or framing context for the agent\u2019s behavior.</p> </li> <li> <p>Goal \u2013 The task or objective the agent is trying to achieve.</p> </li> <li> <p>Step Graph \u2013 A flow structure of logical steps the agent executes in order, conditionally, or iteratively.</p> </li> <li> <p>Memory Strategy \u2013 Defines how the agent stores, summarizes, and retrieves contextual information across steps.</p> </li> <li> <p>Toolchain and Hooks (optional) \u2013 Tools the agent can call and hooks for evaluation, logging, or transformation.</p> </li> </ul> <p>By encapsulating these into a recipe, Minions makes it easy to spin up different kinds of agents, each purpose-built for a use case, without rewriting orchestration logic.</p>"},{"location":"02%20-%20Step%20Graph.html","title":"Step Graph","text":"<p>A Step Graph defines the structured flow of logic an agent follows to reach its goal. Unlike ad hoc prompt chaining, Minions formalizes execution paths using a graph of steps connected by transitions.</p>"},{"location":"02%20-%20Step%20Graph.html#components","title":"Components","text":"<ul> <li>Step: A unit of logic or decision. A step can invoke a model, execute a tool call, or make a transition decision.</li> <li>StepGraphDefinition: Declarative definition of steps and their transitions.</li> <li>TransitionStrategy: Defines how the agent determines the next step. Can be sequential, conditional, or dynamic.</li> <li>Start Step / Terminal Step: Every graph has an entry point and can define one or more terminal states.</li> </ul>"},{"location":"02%20-%20Step%20Graph.html#step-execution-flow","title":"Step Execution Flow","text":"<ol> <li>Agent starts at the defined start step.</li> <li>Executes step logic: e.g., prompts the model, triggers a tool, processes memory.</li> <li>Determines the next step using a transition strategy.</li> <li>Repeats until a terminal step is reached or a completion condition is satisfied.</li> </ol>"},{"location":"02%20-%20Step%20Graph.html#customizing-step-graphs","title":"Customizing Step Graphs","text":"<p>Minions supports a Definition/Customizer pattern:</p> <ul> <li>Definition defines the logic and structure.</li> <li>Customizers allow injection of additional behavior, transitions, or overrides without modifying the core.</li> </ul> <p>This allows default agent flows to be extended in context-aware ways\u2014e.g., adding a retry step only in certain environments.</p>"},{"location":"03%20-%20Memory%20Management.html","title":"Memory Management","text":"<p>Memory is a first-class concept in Minions. It gives agents the ability to remember context, recall facts, and summarize experiences across steps.</p>"},{"location":"03%20-%20Memory%20Management.html#memory-types","title":"Memory Types","text":"<ul> <li>Chat Memory: Stores ongoing interactions (user, assistant, system messages).</li> <li>Step-local Memory: Temporary memory scoped to a single step.</li> <li>Long-Term Memory: Structured storage for facts, retrieved through semantic or attribute-based queries.</li> </ul>"},{"location":"03%20-%20Memory%20Management.html#memory-strategies","title":"Memory Strategies","text":"<p>Memory behavior is pluggable via <code>MemoryStrategy</code> interfaces:</p> <ul> <li>Append: Simply add new messages to memory.</li> <li>Windowed: Keep only the latest N messages.</li> <li>Summarize: Condense older memory into summaries.</li> <li>Flush and Rebuild: Clear old memory and retain only key state.</li> </ul> <p>You can define your own strategy by implementing <code>MemoryStrategy&lt;T extends ProcessContext&gt;</code> and wiring it via Spring.</p>"},{"location":"03%20-%20Memory%20Management.html#memory-query-dsl","title":"Memory Query DSL","text":"<p>Minions provides a DSL to express queries over memory:</p> <pre><code>MemoryQuery query = MemoryQuery.builder()\n    .expression(ExprUtil.getUserMessagesExpression(\"C1\")\n        .and(Expr.contains(\"content\", \"Hello\"))\n        .and(Expr.metadata(\"entityType\", \"testEntity\")))\n    .limit(10)\n    .build();\n</code></pre> <p>This allows agents to retrieve only relevant subsets of memory for each step.</p>"},{"location":"04%20-%20Process%20Chains.html","title":"Process Chains","text":"<p>Minions uses the Chain of Responsibility pattern to handle agent behaviors in a modular way.</p>"},{"location":"04%20-%20Process%20Chains.html#chains-are-used-in","title":"Chains are used in:","text":"<ul> <li>Step Completion Evaluation</li> <li>Memory Summarization</li> <li>Tool Selection</li> <li>Custom Output Evaluation</li> </ul> <p>Each chain is made of <code>Processor&lt;T extends ProcessContext&gt;</code> implementations that can be prioritized and conditionally applied.</p>"},{"location":"04%20-%20Process%20Chains.html#defining-a-processor","title":"Defining a Processor","text":"<pre><code>@Component\npublic class MaxModelCallCountProcessor\n        extends AbstractProcessor&lt;StepGraphCompletionContext&lt;ProcessResult&lt;StepCompletionOutcome&gt;&gt;, StepCompletionOutcome&gt; {\n\n    @Override\n    public StepCompletionOutcome doProcess(StepGraphCompletionContext input) {\n        // Custom logic\n    }\n}\n</code></pre> <p>Processors can expose Customizers to inject logic conditionally during Spring bootstrapping.</p>"},{"location":"05%20-%20Tool%20Integration.html","title":"Tool Integration","text":"<p>Agents often rely on tools to gather data, make external API calls, or trigger workflows.</p>"},{"location":"05%20-%20Tool%20Integration.html#defining-a-tool","title":"Defining a Tool","text":"<p>A tool is a Spring Bean implementing <code>Tool&lt;TInput, TOutput&gt;</code>. It must define:</p> <ul> <li>The name and input schema</li> <li>Execution logic (usually async)</li> <li>Optionally: tool metadata and dynamic arguments</li> </ul>"},{"location":"05%20-%20Tool%20Integration.html#tool-usage-flow","title":"Tool Usage Flow","text":"<ol> <li>Step issues a tool call request.</li> <li>Tool resolves parameters and executes logic.</li> <li>Output is passed to the agent and can be stored in memory or used for reasoning.</li> </ol>"},{"location":"06%20-%20MCP%20Compliance.html","title":"MCP Compliance","text":"<p>Minions adheres to the Model Connector Protocol (MCP):</p> <ul> <li>Agent Recipes define system prompts and goals</li> <li>Step Graphs enable structured orchestration</li> <li>Memory strategies respect MCP\u2019s memory boundaries</li> <li>Tool calls are structured and interoperable</li> </ul> <p>This makes Minions compatible with emerging standards in agent orchestration and allows potential future interop with platforms like LangGraph.</p>"},{"location":"07%20-%20Spring%20Integration.html","title":"Spring Integration","text":"<p>Minions is built around idiomatic Spring patterns:</p> <ul> <li>Use <code>@Component</code> to register custom steps, processors, tools, strategies</li> <li><code>@ConfigurationProperties</code> for loading recipe or agent configuration from YAML or application context</li> <li>Conditional wiring using Spring Boot's auto-config features</li> </ul> <p>You can fully extend Minions without modifying its internals, using standard Spring idioms.</p>"},{"location":"08%20-%20Evaluation%20%26%20Observability.html","title":"Evaluation & Observability","text":"<p>Minions supports observability hooks throughout the agent lifecycle:</p> <ul> <li>Step-level evaluations</li> <li>Memory inspection</li> <li>Custom evaluators for response scoring or compliance</li> <li>Audit trails and trace IDs</li> </ul> <p>Observers can be attached declaratively in recipes or dynamically at runtime.</p>"},{"location":"09%20-%20Privacy%20%26%20Governance.html","title":"Privacy & Governance","text":"<p>Minions was designed with regulated industries in mind.</p> <ul> <li>PII Filters: Redact or transform sensitive information before it enters models or tools.</li> <li>Multi-tenant Memory Isolation: Each tenant has scoped memory and tool access.</li> <li>Audit Hooks: Every agent action is traceable and timestamped.</li> <li>Local LLM Integration: Optional fallback to local models for privacy-sensitive steps.</li> </ul>"},{"location":"10%20-%20Extending%20Minions.html","title":"Extending Minions","text":"<p>Minions is modular. You can extend it by:</p> <ul> <li>Creating new <code>Step</code>, <code>Tool</code>, <code>Processor</code>, or <code>MemoryStrategy</code></li> <li>Defining new transition strategies</li> <li>Injecting custom evaluators, observers, filters</li> <li>Composing new <code>AgentRecipe</code> classes</li> </ul>"},{"location":"11%20-%20Examples.html","title":"Examples","text":"<ul> <li>ReAct Agent with Memory and Tools: A reasoning agent that reads from memory and calls external APIs.</li> <li>Planner with Conditional Branching: Plan, act, and re-evaluate based on tool outcomes.</li> <li>Privacy-Aware Agent: Uses filters to redact user PII before prompting the model.</li> </ul>"},{"location":"12%20-%20Testing%20%26%20Debugging.html","title":"Testing & Debugging","text":"<ul> <li>Unit test Steps, Recipes, and Chains using JUnit + Spring Boot Test</li> <li>Mock model responses and tool outputs</li> <li>View memory snapshots between steps</li> <li>Trace execution via built-in logging topics</li> </ul>"},{"location":"13%20-%20Roadmap%20%26%20Contribution.html","title":"Roadmap & Contribution","text":"<ul> <li>Support for Google A2A multi-agent protocol</li> <li>Visual step graph debugger</li> <li>RAG-native agent types</li> <li>Python bridge (interop with LangChain tools)</li> <li>Contributions welcome via GitHub</li> </ul>"},{"location":"_Index.html","title":"\ud83d\udcda Minions Developer Documentation","text":"<p>Welcome to the official developer documentation for the Minions Framework.</p>"},{"location":"_Index.html#table-of-contents","title":"\ud83d\udcd1 Table of Contents","text":"<ol> <li>[[00 - Overview|Overview]]</li> <li>[[01 - Core Concepts|Core Concepts]]</li> <li>[[02 - Step Graph|Step Graph]]</li> <li>[[03 - Memory Management|Memory Management]]</li> <li>[[04 - Process Chains|Process Chains]]</li> <li>[[05 - Tool Integration|Tool Integration]]</li> <li>[[06 - MCP Compliance|MCP Compliance]]</li> <li>[[07 - Spring Integration|Spring Integration]]</li> <li>[[08 - Evaluation &amp; Observability|Evaluation &amp; Observability]]</li> <li>[[09 - Privacy &amp; Governance|Privacy &amp; Governance]]</li> <li>[[10 - Extending Minions|Extending Minions]]</li> <li>[[11 - Examples|Examples]]</li> <li>[[12 - Testing &amp; Debugging|Testing &amp; Debugging]]</li> <li>[[13 - Roadmap &amp; Contribution|Roadmap &amp; Contribution]]</li> </ol>"}]}