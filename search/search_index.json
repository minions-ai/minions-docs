{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Minions: An Extensible Agentic AI Framework for Java","text":"<p>Minions is a powerful, MCP-compliant agentic AI framework designed for the enterprise Java ecosystem. Built with idiomatic Spring practices, it provides a robust foundation for creating and orchestrating autonomous AI agents in complex and regulated environments.</p> <p>The framework is architected around a core philosophy:</p> <p>The Open/Closed Principle: The system is open for extension but closed for modification.</p> <p>This means you can build anything from a simple ReAct-style agent to a sophisticated planner-executor pipeline without ever needing to alter the core framework code.</p>"},{"location":"index.html#why-minions","title":"Why Minions?","text":"<p>While many agentic frameworks exist for Python, Minions uniquely brings this cutting-edge capability to enterprise Java development. It's designed from the ground up to support the demands of modern, secure, and scalable applications.</p> <ul> <li>Idiomatic Spring Integration: Leverages Spring Boot auto-configuration, dependency injection, and familiar idioms for seamless development.</li> <li>Modular &amp; Extensible: Easily add new components\u2014tools, memory systems, or agent steps\u2014as standard Spring Beans.</li> <li>Governance by Design: Built with features like audit hooks, multi-tenant data isolation, and memory privacy for regulated industries.</li> <li>Multi-Tiered Memory: Features a sophisticated memory architecture with pluggable strategies for querying, persistence, and summarization.</li> <li>Enterprise-Grade Persistence: Integrates seamlessly with Spring Data for robust, scalable data storage.</li> </ul>"},{"location":"index.html#core-design-principles","title":"Core Design Principles","text":"<ul> <li> <p>Extensibility First Minions utilizes proven design patterns, such as the Factory Registry and Chain of Responsibility, to ensure seamless integration of custom components.</p> </li> <li> <p>MCP Compliance Adherence to the Model Context Protocol (MCP) ensures architectural clarity, composability, and interoperability between different models and tools.</p> </li> <li> <p>Enterprise Readiness With features like structured evaluation and memory management designed for privacy, Minions is ready for deployment in finance, healthcare, and insurance.</p> </li> </ul>"},{"location":"index.html#sophisticated-memory-architecture","title":"Sophisticated Memory Architecture","text":"<p>Minions features a pluggable, multi-tiered memory system that you can customize to your needs. Out of the box, it provides a powerful layered approach:</p> <ul> <li>Short-Term Memory: Manages the active context for immediate tasks.</li> <li>Episodic Memory: Stores a chronological history of events and interactions.</li> <li>Vector Memory: Enables semantic search over vast amounts of information.</li> <li>Long-Term Memory: Provides persistent, long-term knowledge storage.</li> </ul> <p>Each subsystem is managed by pluggable strategies for querying, persistence, summarization, and privacy, giving you full control over how your agent remembers and forgets.</p>"},{"location":"index.html#agent-recipes","title":"Agent Recipes","text":"<p>Every agent in Minions is configured using a Recipe. A recipe is a blueprint that defines the agent's behavior and capabilities.</p> <p>A recipe specifies:</p> <ul> <li>The agent's system prompt and ultimate goal.</li> <li>The step graph, which outlines its reasoning and action flow.</li> <li>Its complete memory configuration, including which subsystems to use and how they behave.</li> <li>The toolchains and observers available to the agent.</li> </ul> <p>Minions includes several pre-built recipes to get you started, such as <code>ReActAgentRecipe</code> and <code>PlannerExecutorObserverRecipe</code>, with a clear path to creating your own.</p>"},{"location":"01%20-%20Core%20Concepts.html","title":"Core Concepts","text":"<p>Understanding the foundational elements of Minions is essential before diving into its deeper architecture. This section introduces the two most important constructs: Agents and Recipes.</p>"},{"location":"01%20-%20Core%20Concepts.html#what-is-an-agent","title":"What is an Agent?","text":"<p>In Minions, an Agent is an autonomous entity capable of executing a goal-driven process. It engages in multi-step reasoning, decision-making, and tool interaction. Each agent operates within a defined context, maintaining state across steps and coordinating its behavior using recipes, memory, and step graphs.</p>"},{"location":"01%20-%20Core%20Concepts.html#agent-lifecycle","title":"Agent Lifecycle","text":"<ol> <li> <p>Initialization: The agent is instantiated from a recipe. This includes loading its system prompt, goal, memory configuration, and step graph.</p> </li> <li> <p>Goal Assignment: A goal is defined either at instantiation or injected dynamically (e.g., from user input or a higher-level planner).</p> </li> <li> <p>Step Execution: The agent traverses its step graph, making decisions, calling models, and interacting with tools as needed.</p> </li> <li> <p>Memory Management: The agent maintains multiple memory subsystems:</p> <ul> <li>Episodic memory for chronological event storage</li> <li>Vector memory for semantic similarity search</li> <li>Short-term memory for active context</li> <li>Long-term memory for persistent knowledge</li> </ul> </li> <li> <p>Memory Summarization: After each step, the agent:</p> <ul> <li>Queries relevant memory based on context</li> <li>Generates summaries using model calls</li> <li>Updates appropriate memory subsystems</li> <li>Maintains memory efficiency through summarization</li> </ul> </li> <li> <p>Completion: The agent completes once the graph reaches a terminal node or a completion condition is met.</p> </li> </ol> <p>Agents are MCP-compliant and traceable, allowing developers to monitor execution, review decision points, and integrate with observability tooling.</p>"},{"location":"01%20-%20Core%20Concepts.html#what-is-a-recipe","title":"What is a Recipe?","text":"<p>A Recipe is a declarative blueprint for constructing an agent. Rather than configuring agents imperatively through code, developers define recipes that describe the agent's identity, structure, and behavior.</p> <p>A recipe includes:</p> <ul> <li> <p>System Prompt \u2013 The initial set of instructions or framing context for the agent's behavior.</p> </li> <li> <p>Goal \u2013 The task or objective the agent is trying to achieve.</p> </li> <li> <p>Step Graph \u2013 A flow structure of logical steps the agent executes in order, conditionally, or iteratively.</p> </li> <li> <p>Memory Configuration \u2013 Defines how the agent manages memory:</p> <ul> <li>Memory subsystem selection and configuration</li> <li>Query strategy configuration</li> <li>Summarization settings</li> <li>Persistence strategy selection</li> </ul> </li> <li> <p>Toolchain and Hooks (optional) \u2013 Tools the agent can call and hooks for evaluation, logging, or transformation.</p> </li> </ul> <p>By encapsulating these into a recipe, Minions makes it easy to spin up different kinds of agents, each purpose-built for a use case, without rewriting orchestration logic.</p>"},{"location":"02%20-%20Step%20Graph.html","title":"Step Graph","text":"<p>A Step Graph defines the structured flow of logic an agent follows to reach its goal. Unlike ad hoc prompt chaining, Minions formalizes execution paths using a graph of steps connected by transitions.</p>"},{"location":"02%20-%20Step%20Graph.html#components","title":"Components","text":"<ul> <li>Step: A unit of logic or decision. A step can:</li> <li>Invoke a model</li> <li>Execute a tool call</li> <li>Query or update memory</li> <li>Make a transition decision</li> <li>StepGraphDefinition: Declarative definition of steps and their transitions</li> <li>TransitionStrategy: Defines how the agent determines the next step</li> <li>Sequential transitions</li> <li>Conditional transitions</li> <li>Dynamic transitions based on memory state</li> <li>Start Step / Terminal Step: Every graph has an entry point and can define one or more terminal states</li> </ul>"},{"location":"02%20-%20Step%20Graph.html#memory-aware-steps","title":"Memory-Aware Steps","text":"<p>Steps can interact with memory subsystems:</p> <pre><code>@Component\npublic class MemoryAwareStep implements Step {\n    private final MemoryManager memoryManager;\n\n    @Override\n    public StepResult execute(StepContext context) {\n        // Query memory\n        List&lt;Message&gt; memory = memoryManager.query(context);\n\n        // Store results\n        memoryManager.store(MemorySubsystem.EPISODIC, result);\n\n        return StepResult.builder()\n            .outcome(StepCompletionOutcome.COMPLETE)\n            .build();\n    }\n}\n</code></pre>"},{"location":"02%20-%20Step%20Graph.html#step-execution-flow","title":"Step Execution Flow","text":"<ol> <li>Agent starts at the defined start step</li> <li>Executes step logic:</li> <li>Prompts the model</li> <li>Triggers a tool</li> <li>Queries memory subsystems</li> <li>Processes memory results</li> <li>Determines the next step using a transition strategy</li> <li>Repeats until a terminal step is reached or a completion condition is satisfied</li> </ol>"},{"location":"02%20-%20Step%20Graph.html#memory-integration","title":"Memory Integration","text":"<p>Steps can integrate with memory in several ways:</p> <ol> <li>Memory Query</li> </ol> <pre><code>MemoryQuery query = MemoryQuery.builder()\n    .expression(Expr.eq(\"conversationId\", context.getConversationId()))\n    .limit(10)\n    .build();\nList&lt;Message&gt; results = memoryManager.query(query);\n</code></pre> <ol> <li>Memory Storage</li> </ol> <pre><code>memoryManager.store(MemorySubsystem.EPISODIC, message);\nmemoryManager.store(MemorySubsystem.VECTOR, message);\n</code></pre> <ol> <li>Memory Summarization</li> </ol> <pre><code>@Autowired\nprivate MemorySummarizerProcessor summarizer;\n\npublic StepResult execute(StepContext context) {\n    summarizer.process(context);\n    // Continue with step logic\n}\n</code></pre>"},{"location":"02%20-%20Step%20Graph.html#customizing-step-graphs","title":"Customizing Step Graphs","text":"<p>Minions supports a Definition/Customizer pattern:</p> <ul> <li>Definition defines the logic and structure</li> <li>Customizers allow injection of additional behavior:</li> <li>Memory query strategies</li> <li>Memory summarization rules</li> <li>Persistence configurations</li> <li>Transitions based on memory state</li> </ul> <p>This allows default agent flows to be extended in context-aware ways\u2014e.g., adding memory-aware retry steps or custom memory processing logic.</p>"},{"location":"03%20-%20Memory%20Management.html","title":"Memory Management","text":"<p>Memory is a first-class concept in Minions. It gives agents the ability to remember context, recall facts, and summarize experiences across steps.</p>"},{"location":"03%20-%20Memory%20Management.html#memory-subsystems","title":"Memory Subsystems","text":"<p>Minions implements a multi-tiered memory architecture:</p> <ul> <li>Episodic Memory: Stores sequences of events and experiences in chronological order</li> <li>Vector Memory: Stores semantic representations of messages for similarity-based retrieval</li> <li>Short-Term Memory: Maintains recent context and active working memory</li> <li>Long-Term Memory: Stores persistent knowledge and facts across conversations</li> </ul>"},{"location":"03%20-%20Memory%20Management.html#memory-query-strategies","title":"Memory Query Strategies","text":"<p>Memory querying is implemented through pluggable strategies that determine how to retrieve information:</p>"},{"location":"03%20-%20Memory%20Management.html#step-based-strategies","title":"Step-based Strategies","text":"<ul> <li>StepVectorQueryStrategy: Handles vector-based queries within step context</li> <li>StepShortTermQueryStrategy: Manages short-term memory queries for steps</li> <li>StepEntityQueryStrategy: Handles entity-based queries within step context</li> </ul>"},{"location":"03%20-%20Memory%20Management.html#agent-based-strategies","title":"Agent-based Strategies","text":"<ul> <li>AgentVectorQueryStrategy: Manages vector-based queries at agent level</li> <li>AgentShortTermQueryStrategy: Handles short-term memory queries for agents</li> <li>AgentLongTermQueryStrategy: Manages long-term memory queries for agents</li> <li>AgentEntityQueryStrategy: Handles entity-based queries at agent level</li> </ul>"},{"location":"03%20-%20Memory%20Management.html#memory-operations","title":"Memory Operations","text":"<p>The <code>MemoryManager</code> coordinates memory operations across subsystems:</p> <pre><code>// Store messages in specific memory subsystem\nmemoryManager.store(MemorySubsystem.EPISODIC, message);\n\n// Query memory using DSL\nMemoryQuery query = MemoryQuery.builder()\n    .expression(Expr.eq(\"conversationId\", \"C1\"))\n    .limit(10)\n    .build();\nList&lt;Message&gt; results = memoryManager.query(query);\n\n// Retrieve specific message\nMessage message = memoryManager.retrieve(\"messageId\");\n\n// Flush memory\nmemoryManager.flush();\n</code></pre>"},{"location":"03%20-%20Memory%20Management.html#memory-persistence","title":"Memory Persistence","text":"<p>Memory persistence is handled through pluggable strategies:</p> <ul> <li>InMemoryPersistence: Default strategy for development and testing</li> <li>PostgresPersistence: Production-ready persistence using PostgreSQL</li> <li>Custom Persistence: Implement <code>PersistenceStrategy</code> for custom storage</li> </ul>"},{"location":"03%20-%20Memory%20Management.html#memory-summarization","title":"Memory Summarization","text":"<p>The <code>MemorySummarizerProcessor</code> handles memory summarization:</p> <ol> <li>Queries relevant memory based on conversation context</li> <li>Uses model calls to generate summaries</li> <li>Stores summaries in appropriate memory subsystems</li> <li>Maintains memory efficiency by condensing older information</li> </ol>"},{"location":"03%20-%20Memory%20Management.html#configuration","title":"Configuration","text":"<p>Memory behavior is configured through:</p> <pre><code>SummarizationConfig config = SummarizationConfig.builder()\n    .inputMessageLimit(10)\n    .modelConfig(modelConfig)\n    .build();\n</code></pre> <p>This allows fine-tuning of: - Message limits for summarization - Model selection for summarization - Memory subsystem behavior - Query strategy selection</p>"},{"location":"03%20-%20Memory%20Management.html#memory-query-system","title":"Memory Query System","text":"<p>The memory query system provides a flexible and expressive way to retrieve messages from memory subsystems. It consists of two main components: <code>MemoryQuery</code> and <code>MemoryQueryExpression</code>.</p>"},{"location":"03%20-%20Memory%20Management.html#memoryquery","title":"MemoryQuery","text":"<p><code>MemoryQuery</code> is the main query object for retrieving messages from memory. It is implemented using Lombok annotations for builder pattern and data access:</p> <pre><code>@Data\n@Accessors(chain = true)\n@EqualsAndHashCode\n@AllArgsConstructor\n@Builder\n@ToString\npublic class MemoryQuery {\n    private MemorySubsystem subsystems;\n    private int limit;\n    private MemoryQueryExpression expression;\n\n    public MemoryQuery(@NotBlank MemorySubsystem subsystem, int limit) {\n        this.subsystems = subsystem;\n        this.limit = limit;\n    }\n}\n</code></pre>"},{"location":"03%20-%20Memory%20Management.html#memoryqueryexpression","title":"MemoryQueryExpression","text":"<p><code>MemoryQueryExpression</code> is the base interface for all query expressions. It provides: - A method to evaluate messages against the expression - Default methods for logical operations (AND, OR, NOT) - Support for expression composition</p> <pre><code>public interface MemoryQueryExpression {\n    boolean evaluate(Message message);\n\n    default MemoryQueryExpression and(MemoryQueryExpression... expressions) {\n        List&lt;MemoryQueryExpression&gt; all = new ArrayList&lt;&gt;();\n        all.add(this);\n        Collections.addAll(all, expressions);\n        return new LogicalExpression(LogicalOperator.AND, all);\n    }\n\n    // Similar default methods for or() and not()\n}\n</code></pre> <p>The framework provides several built-in expression types:</p> <ol> <li>FieldEqualsExpression</li> <li> <p>Matches exact field values    <code>java    Expr.eq(\"role\", MessageRole.USER)</code></p> </li> <li> <p>ContainsKeywordExpression</p> </li> <li> <p>Searches for keywords in text fields    <code>java    Expr.contains(\"content\", \"keyword\")</code></p> </li> <li> <p>RangeExpression</p> </li> <li> <p>Filters by time ranges    <code>java    Expr.after(\"timestamp\", Instant.now().minus(Duration.ofDays(1)))</code></p> </li> <li> <p>MetadataMatchExpression</p> </li> <li> <p>Matches metadata key-value pairs    <code>java    Expr.metadata(\"priority\", \"high\")</code></p> </li> <li> <p>VectorSimilarityExpression</p> </li> <li> <p>Performs vector similarity search (placeholder implementation)    <code>java    Expr.vector(embedding, topK)</code></p> </li> <li> <p>LogicalExpression</p> </li> <li> <p>Combines expressions with AND, OR, NOT    <code>java    Expr.and(        Expr.eq(\"role\", MessageRole.USER),        Expr.contains(\"content\", \"keyword\")    )</code></p> </li> <li> <p>AlwaysTrueExpression</p> </li> <li>Default expression that always evaluates to true    <code>java    Expr.alwaysTrue()</code></li> </ol>"},{"location":"03%20-%20Memory%20Management.html#query-building","title":"Query Building","text":"<p>The <code>QueryBuilder</code> class provides a fluent API for constructing queries, with some methods returning expressions directly:</p> <pre><code>// Returns MemoryQueryExpression\nMemoryQueryExpression roleExpr = new QueryBuilder()\n    .role(MessageRole.USER);\n\n// Returns QueryBuilder for chaining\nMemoryQuery query = new QueryBuilder()\n    .scope(MessageScope.CONVERSATION)\n    .keyword(\"important\")\n    .after(Instant.now().minus(Duration.ofHours(1)))\n    .entityType(\"user\")\n    .conversationId(\"conv123\")\n    .metadata(Map.of(\"priority\", \"high\"))\n    .build();\n</code></pre>"},{"location":"03%20-%20Memory%20Management.html#query-translation","title":"Query Translation","text":"<p>Queries can be translated to different backend formats with parameter binding:</p> <ol> <li> <p>MongoDB <code>java    Query mongoQuery = mongoQueryTranslator.translate(memoryQuery);    // Translates to Spring Data MongoDB Query with Criteria</code></p> </li> <li> <p>PostgreSQL <code>java    String sql = postgresQueryTranslator.translate(memoryQuery);    // Generates parameterized SQL with ? placeholders</code></p> </li> <li> <p>In-Memory <code>java    List&lt;Message&gt; results = messages.stream()        .filter(message -&gt; expression.evaluate(message))        .collect(Collectors.toList());</code></p> </li> </ol>"},{"location":"03%20-%20Memory%20Management.html#common-query-patterns","title":"Common Query Patterns","text":"<p>The <code>MemoryQueryUtils</code> class provides utility methods for common query patterns, with type filtering:</p> <pre><code>// Get last N user messages with type filtering\nList&lt;Message&gt; userMessages = MemoryQueryUtils.getLastNUserMessages(\n    memoryManager, 5, \"conv123\")\n    .stream()\n    .filter(Message.class::isInstance)\n    .map(message -&gt; message)\n    .collect(Collectors.toList());\n\n// Get last N assistant messages with subsystem specification\nList&lt;Message&gt; assistantMessages = MemoryQueryUtils.getLastNAssistantMessages(\n    memoryManager, 5, \"conv123\");\n\n// Get entities of specific type with subsystem specification\nList&lt;Message&gt; userEntities = MemoryQueryUtils.getEntitiesOfType(\n    memoryManager, \"user\");\n</code></pre>"},{"location":"03%20-%20Memory%20Management.html#query-strategies","title":"Query Strategies","text":"<p>Query strategies implement the <code>MemoryQueryStrategy</code> interface to provide context-aware querying:</p> <ol> <li>Agent Strategies</li> <li><code>AgentEntityQueryStrategy</code>: Queries entity memory with <code>AlwaysTrueExpression</code></li> <li><code>AgentVectorQueryStrategy</code>: Performs vector similarity search</li> <li><code>AgentShortTermQueryStrategy</code>: Queries short-term memory using <code>ExprUtil</code></li> <li> <p><code>AgentLongTermQueryStrategy</code>: Queries long-term memory with recipe ID</p> </li> <li> <p>Step Strategies</p> </li> <li><code>StepEntityQueryStrategy</code>: Queries entity memory with <code>AlwaysTrueExpression</code></li> <li><code>StepVectorQueryStrategy</code>: Performs vector similarity search</li> <li><code>StepShortTermQueryStrategy</code>: Queries short-term memory using <code>ExprUtil</code></li> </ol> <p>Each strategy: - Implements <code>getMemoryQuery</code> to build appropriate queries using <code>QueryConfig</code> - Specifies supported memory subsystems - Defines context acceptance criteria - Uses <code>MemoryManager</code>'s <code>queryStrategies</code> for execution</p>"},{"location":"04%20-%20Process%20Chains.html","title":"Process Chains","text":"<p>Minions uses the Chain of Responsibility pattern to handle agent behaviors in a modular way. This pattern allows for flexible composition of behaviors and easy extension of functionality.</p>"},{"location":"04%20-%20Process%20Chains.html#chains-are-used-in","title":"Chains are used in:","text":"<ul> <li>Step Completion Evaluation</li> <li>Memory Management</li> <li>Memory Summarization</li> <li>Memory Query Execution</li> <li>Memory Persistence</li> <li>Tool Selection</li> <li>Custom Output Evaluation</li> </ul> <p>Each chain is made of <code>Processor&lt;T extends ProcessContext&gt;</code> implementations that can be prioritized and conditionally applied.</p>"},{"location":"04%20-%20Process%20Chains.html#memory-processors","title":"Memory Processors","text":""},{"location":"04%20-%20Process%20Chains.html#memory-summarizer-processor","title":"Memory Summarizer Processor","text":"<pre><code>@Component\npublic class MemorySummarizerProcessor implements Processor&lt;AgentContext&gt; {\n    private final ModelCallService modelCallService;\n\n    @Override\n    public AgentContext process(AgentContext input) {\n        // Query memory based on context\n        // Generate summaries using model calls\n        // Store summaries in appropriate subsystems\n        return input;\n    }\n}\n</code></pre>"},{"location":"04%20-%20Process%20Chains.html#memory-query-processors","title":"Memory Query Processors","text":"<pre><code>@Component\npublic class StepVectorQueryStrategy implements MemoryQueryStrategy {\n    @Override\n    public MemoryQuery getMemoryQuery(ProcessContext context) {\n        // Build and return memory query\n    }\n\n    @Override\n    public List&lt;MemorySubsystem&gt; getSupportedSubsystem() {\n        return List.of(MemorySubsystem.VECTOR);\n    }\n}\n</code></pre>"},{"location":"04%20-%20Process%20Chains.html#defining-a-processor","title":"Defining a Processor","text":"<pre><code>@Component\npublic class MaxModelCallCountProcessor\n        extends AbstractProcessor&lt;StepGraphCompletionContext&lt;ProcessResult&lt;StepCompletionOutcome&gt;&gt;, StepCompletionOutcome&gt; {\n\n    @Override\n    public StepCompletionOutcome doProcess(StepGraphCompletionContext input) {\n        // Custom logic\n    }\n}\n</code></pre>"},{"location":"04%20-%20Process%20Chains.html#processor-configuration","title":"Processor Configuration","text":"<p>Processors can be configured through:</p> <ol> <li>Spring Configuration</li> </ol> <pre><code>@Configuration\npublic class ProcessorConfig {\n    @Bean\n    public Processor&lt;AgentContext&gt; memorySummarizerProcessor(ModelCallService modelCallService) {\n        return new MemorySummarizerProcessor(modelCallService);\n    }\n}\n</code></pre> <ol> <li>Customizers</li> </ol> <pre><code>@Component\npublic class MemoryProcessorCustomizer implements ProcessorCustomizer&lt;MemorySummarizerProcessor&gt; {\n    @Override\n    public void customize(MemorySummarizerProcessor processor) {\n        // Custom configuration\n    }\n}\n</code></pre>"},{"location":"04%20-%20Process%20Chains.html#testing-processors","title":"Testing Processors","text":"<pre><code>@ExtendWith(MockitoExtension.class)\nclass MemorySummarizerProcessorTest {\n    @Mock\n    private AgentContext context;\n    @Mock\n    private ModelCallService modelCallService;\n\n    @Test\n    void testProcess() {\n        MemorySummarizerProcessor processor = new MemorySummarizerProcessor(modelCallService);\n        AgentContext result = processor.process(context);\n        // Verify behavior\n    }\n}\n</code></pre> <p>Processors can expose Customizers to inject logic conditionally during Spring bootstrapping.</p>"},{"location":"05%20-%20Tool%20Integration.html","title":"Tool Integration","text":"<p>Agents often rely on tools to gather data, make external API calls, or trigger workflows. Tools can also interact with memory subsystems to store and retrieve information.</p>"},{"location":"05%20-%20Tool%20Integration.html#defining-a-tool","title":"Defining a Tool","text":"<p>A tool is a Spring Bean implementing <code>Tool&lt;TInput, TOutput&gt;</code>. It must define:</p> <ul> <li>The name and input schema</li> <li>Execution logic (usually async)</li> <li>Optionally: tool metadata and dynamic arguments</li> <li>Memory integration points</li> </ul>"},{"location":"05%20-%20Tool%20Integration.html#memory-aware-tools","title":"Memory-Aware Tools","text":"<p>Tools can interact with memory subsystems:</p> <pre><code>@Component\npublic class MemoryAwareTool implements Tool&lt;ToolInput, ToolOutput&gt; {\n    private final MemoryManager memoryManager;\n\n    @Override\n    public ToolOutput execute(ToolInput input) {\n        // Query memory for context\n        List&lt;Message&gt; context = memoryManager.query(input.getContext());\n\n        // Execute tool logic\n        ToolOutput output = process(input, context);\n\n        // Store results in memory\n        memoryManager.store(MemorySubsystem.EPISODIC, output.toMessage());\n\n        return output;\n    }\n}\n</code></pre>"},{"location":"05%20-%20Tool%20Integration.html#tool-usage-flow","title":"Tool Usage Flow","text":"<ol> <li>Step issues a tool call request</li> <li>Tool resolves parameters and executes logic:</li> <li>Queries memory for context</li> <li>Performs tool-specific operations</li> <li>Stores results in memory</li> <li>Output is passed to the agent and can be:</li> <li>Stored in memory subsystems</li> <li>Used for reasoning</li> <li>Summarized for long-term storage</li> </ol>"},{"location":"05%20-%20Tool%20Integration.html#memory-integration-points","title":"Memory Integration Points","text":"<p>Tools can integrate with memory at several points:</p> <ol> <li>Pre-execution</li> </ol> <pre><code>// Query memory for context\nMemoryQuery query = MemoryQuery.builder()\n    .expression(Expr.eq(\"toolId\", toolId))\n    .limit(5)\n    .build();\nList&lt;Message&gt; context = memoryManager.query(query);\n</code></pre> <ol> <li>Post-execution</li> </ol> <pre><code>// Store tool results\nMessage result = Message.builder()\n    .content(output.toString())\n    .metadata(\"toolId\", toolId)\n    .build();\nmemoryManager.store(MemorySubsystem.EPISODIC, result);\n</code></pre> <ol> <li>Error Handling</li> </ol> <pre><code>try {\n    return execute(input);\n} catch (Exception e) {\n    // Store error in memory\n    Message error = Message.builder()\n        .content(e.getMessage())\n        .metadata(\"error\", true)\n        .build();\n    memoryManager.store(MemorySubsystem.EPISODIC, error);\n    throw e;\n}\n</code></pre>"},{"location":"05%20-%20Tool%20Integration.html#testing-tools","title":"Testing Tools","text":"<pre><code>@ExtendWith(MockitoExtension.class)\nclass MemoryAwareToolTest {\n    @Mock\n    private MemoryManager memoryManager;\n\n    @Test\n    void testExecute() {\n        MemoryAwareTool tool = new MemoryAwareTool(memoryManager);\n        ToolInput input = createTestInput();\n\n        when(memoryManager.query(any())).thenReturn(List.of());\n        ToolOutput output = tool.execute(input);\n\n        verify(memoryManager).query(any());\n        verify(memoryManager).store(eq(MemorySubsystem.EPISODIC), any());\n        assertNotNull(output);\n    }\n}\n</code></pre>"},{"location":"06%20-%20MCP%20Compliance.html","title":"MCP Compliance","text":"<p>Minions is designed to be compatible with the Model Connector Protocol (MCP), with ongoing work to achieve full compliance.</p>"},{"location":"06%20-%20MCP%20Compliance.html#current-implementation","title":"Current Implementation","text":""},{"location":"06%20-%20MCP%20Compliance.html#memory-system","title":"Memory System","text":"<p>The memory system is designed with MCP compatibility in mind:</p> <pre><code>// Memory query with standard fields\nMemoryQuery query = MemoryQuery.builder()\n    .subsystems(MemorySubsystem.EPISODIC)\n    .limit(10)\n    .expression(Expr.eq(\"conversationId\", \"C1\"))\n    .build();\n\n// Message with standard metadata\nMessage message = Message.builder()\n    .content(\"content\")\n    .metadata(\"type\", \"user_message\")\n    .build();\n</code></pre>"},{"location":"06%20-%20MCP%20Compliance.html#memory-subsystems","title":"Memory Subsystems","text":"<p>Memory subsystems follow a modular design that can be extended for MCP compliance:</p> <pre><code>public class EpisodicMemory implements Memory&lt;MemoryContext, Message&gt; {\n    @Override\n    public MemorySubsystem getMemorySubsystem() {\n        return MemorySubsystem.EPISODIC;\n    }\n}\n</code></pre>"},{"location":"06%20-%20MCP%20Compliance.html#planned-mcp-compliance","title":"Planned MCP Compliance","text":"<ol> <li>Memory Operations</li> <li>[ ] Implement MCP-compliant expression types</li> <li>[ ] Add MCP metadata handling</li> <li> <p>[ ] Support MCP-specific query patterns</p> </li> <li> <p>Memory Subsystems</p> </li> <li>[ ] Add MCP interface implementations</li> <li>[ ] Implement MCP metadata providers</li> <li> <p>[ ] Support MCP-specific operations</p> </li> <li> <p>Memory Persistence</p> </li> <li>[ ] Add MCP metadata storage</li> <li>[ ] Support MCP data formats</li> <li>[ ] Implement MCP query language support</li> </ol>"},{"location":"07%20-%20Spring%20Integration.html","title":"Spring Integration","text":"<p>Minions is built on Spring Boot, making it easy to integrate with existing Spring applications and leverage Spring's dependency injection and configuration capabilities.</p>"},{"location":"07%20-%20Spring%20Integration.html#memory-configuration","title":"Memory Configuration","text":""},{"location":"07%20-%20Spring%20Integration.html#memory-subsystems","title":"Memory Subsystems","text":"<pre><code>@Configuration\npublic class MemoryConfig {\n    @Bean\n    public Memory&lt;MemoryContext, Message&gt; episodicMemory() {\n        return new EpisodicMemory();\n    }\n\n    @Bean\n    public Memory&lt;MemoryContext, Message&gt; vectorMemory() {\n        return new VectorMemory();\n    }\n\n    @Bean\n    public MemoryManager memoryManager(\n            List&lt;Memory&lt;MemoryContext, Message&gt;&gt; memories,\n            List&lt;MemoryQueryStrategy&gt; strategies) {\n        return new MemoryManager(memories, strategies);\n    }\n}\n</code></pre>"},{"location":"07%20-%20Spring%20Integration.html#query-strategies","title":"Query Strategies","text":"<pre><code>@Configuration\npublic class QueryStrategyConfig {\n    @Bean\n    public MemoryQueryStrategy stepVectorQueryStrategy() {\n        return new StepVectorQueryStrategy();\n    }\n\n    @Bean\n    public MemoryQueryStrategy agentLongTermQueryStrategy() {\n        return new AgentLongTermQueryStrategy();\n    }\n}\n</code></pre>"},{"location":"07%20-%20Spring%20Integration.html#persistence-configuration","title":"Persistence Configuration","text":"<pre><code>@Configuration\npublic class PersistenceConfig {\n    @Bean\n    public PersistenceStrategy postgresPersistenceStrategy(DataSource dataSource) {\n        return new PostgresPersistenceStrategy(dataSource);\n    }\n}\n</code></pre>"},{"location":"07%20-%20Spring%20Integration.html#auto-configuration","title":"Auto-Configuration","text":"<p>Minions provides auto-configuration for common components:</p> <pre><code>@Configuration\n@ConditionalOnProperty(name = \"minions.memory.enabled\", havingValue = \"true\")\npublic class MemoryAutoConfiguration {\n    @Bean\n    @ConditionalOnMissingBean\n    public MemoryManager memoryManager() {\n        // Default configuration\n    }\n}\n</code></pre>"},{"location":"07%20-%20Spring%20Integration.html#custom-configuration","title":"Custom Configuration","text":"<p>Override default configurations using Spring properties:</p> <pre><code>minions:\n  memory:\n    enabled: true\n    subsystems:\n      episodic:\n        enabled: true\n      vector:\n        enabled: true\n    persistence:\n      type: postgres\n      schema: minions\n</code></pre>"},{"location":"07%20-%20Spring%20Integration.html#testing-support","title":"Testing Support","text":"<p>Spring provides testing utilities for memory components:</p> <pre><code>@SpringBootTest\nclass MemoryIntegrationTest {\n    @Autowired\n    private MemoryManager memoryManager;\n\n    @Test\n    void testMemoryOperations() {\n        // Test memory operations\n    }\n}\n</code></pre> <p>Minions is built around idiomatic Spring patterns:</p> <ul> <li>Use <code>@Component</code> to register custom steps, processors, tools, strategies</li> <li><code>@ConfigurationProperties</code> for loading recipe or agent configuration from YAML or application context</li> <li>Conditional wiring using Spring Boot's auto-config features</li> </ul> <p>You can fully extend Minions without modifying its internals, using standard Spring idioms.</p>"},{"location":"08%20-%20Evaluation%20%26%20Observability.html","title":"Evaluation &amp; Observability","text":"<p>Minions provides comprehensive evaluation and observability features, including memory-specific metrics and monitoring capabilities.</p>"},{"location":"08%20-%20Evaluation%20%26%20Observability.html#memory-metrics","title":"Memory Metrics","text":""},{"location":"08%20-%20Evaluation%20%26%20Observability.html#performance-metrics","title":"Performance Metrics","text":"<pre><code>@Component\npublic class MemoryMetrics {\n    private final MeterRegistry registry;\n\n    public void recordMemoryOperation(\n            String operation,\n            MemorySubsystem subsystem,\n            long duration) {\n        registry.timer(\"memory.operation\", \n            \"operation\", operation,\n            \"subsystem\", subsystem.name())\n            .record(duration, TimeUnit.MILLISECONDS);\n    }\n}\n</code></pre>"},{"location":"08%20-%20Evaluation%20%26%20Observability.html#memory-health","title":"Memory Health","text":"<pre><code>@Component\npublic class MemoryHealthIndicator implements HealthIndicator {\n    private final MemoryManager memoryManager;\n\n    @Override\n    public Health health() {\n        return Health.builder()\n            .withDetail(\"episodic\", checkSubsystem(MemorySubsystem.EPISODIC))\n            .withDetail(\"vector\", checkSubsystem(MemorySubsystem.VECTOR))\n            .build();\n    }\n}\n</code></pre>"},{"location":"08%20-%20Evaluation%20%26%20Observability.html#memory-monitoring","title":"Memory Monitoring","text":""},{"location":"08%20-%20Evaluation%20%26%20Observability.html#query-monitoring","title":"Query Monitoring","text":"<pre><code>@Aspect\n@Component\npublic class MemoryQueryMonitor {\n    @Around(\"execution(* com.minionslab.core.memory.MemoryManager.query(..))\")\n    public Object monitorQuery(ProceedingJoinPoint pjp) {\n        // Monitor query performance\n        // Track query patterns\n        // Alert on anomalies\n    }\n}\n</code></pre>"},{"location":"08%20-%20Evaluation%20%26%20Observability.html#storage-monitoring","title":"Storage Monitoring","text":"<pre><code>@Aspect\n@Component\npublic class MemoryStorageMonitor {\n    @Around(\"execution(* com.minionslab.core.memory.MemoryManager.store(..))\")\n    public Object monitorStorage(ProceedingJoinPoint pjp) {\n        // Monitor storage operations\n        // Track storage patterns\n        // Alert on capacity issues\n    }\n}\n</code></pre>"},{"location":"08%20-%20Evaluation%20%26%20Observability.html#memory-evaluation","title":"Memory Evaluation","text":""},{"location":"08%20-%20Evaluation%20%26%20Observability.html#query-evaluation","title":"Query Evaluation","text":"<pre><code>@Component\npublic class MemoryQueryEvaluator {\n    public QueryEvaluationResult evaluateQuery(\n            MemoryQuery query,\n            List&lt;Message&gt; results) {\n        return QueryEvaluationResult.builder()\n            .relevance(calculateRelevance(results))\n            .completeness(calculateCompleteness(results))\n            .build();\n    }\n}\n</code></pre>"},{"location":"08%20-%20Evaluation%20%26%20Observability.html#summarization-evaluation","title":"Summarization Evaluation","text":"<pre><code>@Component\npublic class MemorySummarizationEvaluator {\n    public SummarizationEvaluationResult evaluateSummary(\n            List&lt;Message&gt; original,\n            Message summary) {\n        return SummarizationEvaluationResult.builder()\n            .coverage(calculateCoverage(original, summary))\n            .accuracy(calculateAccuracy(original, summary))\n            .build();\n    }\n}\n</code></pre>"},{"location":"08%20-%20Evaluation%20%26%20Observability.html#observability-integration","title":"Observability Integration","text":""},{"location":"08%20-%20Evaluation%20%26%20Observability.html#prometheus-metrics","title":"Prometheus Metrics","text":"<pre><code>management:\n  endpoints:\n    web:\n      exposure:\n        include: health,metrics,prometheus\n  metrics:\n    export:\n      prometheus:\n        enabled: true\n</code></pre>"},{"location":"08%20-%20Evaluation%20%26%20Observability.html#grafana-dashboards","title":"Grafana Dashboards","text":"<pre><code>{\n  \"dashboard\": {\n    \"panels\": [\n      {\n        \"title\": \"Memory Operations\",\n        \"type\": \"graph\",\n        \"targets\": [\n          {\n            \"expr\": \"rate(memory_operation_seconds_count[5m])\",\n            \"legendFormat\": \"{{operation}} - {{subsystem}}\"\n          }\n        ]\n      }\n    ]\n  }\n}\n</code></pre>"},{"location":"08%20-%20Evaluation%20%26%20Observability.html#testing-observability","title":"Testing Observability","text":"<pre><code>@Test\nvoid testMemoryMetrics() {\n    MemoryManager manager = new MemoryManager(memories, strategies);\n    manager.store(MemorySubsystem.EPISODIC, message);\n\n    // Verify metrics\n    assertThat(registry.find(\"memory.operation\")\n        .tag(\"operation\", \"store\")\n        .tag(\"subsystem\", \"EPISODIC\")\n        .timer())\n        .isNotNull();\n}\n</code></pre> <p>Minions supports observability hooks throughout the agent lifecycle:</p> <ul> <li>Step-level evaluations</li> <li>Memory inspection</li> <li>Custom evaluators for response scoring or compliance</li> <li>Audit trails and trace IDs</li> </ul> <p>Observers can be attached declaratively in recipes or dynamically at runtime.</p>"},{"location":"09%20-%20Privacy%20%26%20Governance.html","title":"Privacy &amp; Governance","text":"<p>Minions provides built-in support for privacy and governance requirements, particularly in memory management and data handling.</p>"},{"location":"09%20-%20Privacy%20%26%20Governance.html#memory-privacy","title":"Memory Privacy","text":""},{"location":"09%20-%20Privacy%20%26%20Governance.html#data-isolation","title":"Data Isolation","text":"<p>Memory subsystems support multi-tenant isolation:</p> <pre><code>@Configuration\npublic class MemoryPrivacyConfig {\n    @Bean\n    public MemoryManager memoryManager(\n            List&lt;Memory&lt;MemoryContext, Message&gt;&gt; memories,\n            PrivacyConfig privacyConfig) {\n        return new MemoryManager(memories, strategies, privacyConfig);\n    }\n}\n</code></pre>"},{"location":"09%20-%20Privacy%20%26%20Governance.html#privacy-controls","title":"Privacy Controls","text":"<pre><code>public class PrivacyConfig {\n    private final boolean enableDataIsolation;\n    private final boolean enableAuditLogging;\n    private final boolean enableDataRetention;\n\n    // Privacy controls for memory operations\n    public boolean canAccessMemory(String tenantId, MemorySubsystem subsystem) {\n        // Check access permissions\n    }\n\n    public boolean canStoreData(String tenantId, Message message) {\n        // Check storage permissions\n    }\n}\n</code></pre>"},{"location":"09%20-%20Privacy%20%26%20Governance.html#memory-governance","title":"Memory Governance","text":""},{"location":"09%20-%20Privacy%20%26%20Governance.html#audit-logging","title":"Audit Logging","text":"<p>All memory operations are logged for audit purposes:</p> <pre><code>@Component\npublic class MemoryAuditLogger {\n    public void logMemoryOperation(\n            String operation,\n            String tenantId,\n            MemorySubsystem subsystem,\n            Message message) {\n        // Log memory operation\n    }\n}\n</code></pre>"},{"location":"09%20-%20Privacy%20%26%20Governance.html#data-retention","title":"Data Retention","text":"<p>Memory subsystems support configurable retention policies:</p> <pre><code>@Configuration\npublic class RetentionConfig {\n    @Bean\n    public RetentionPolicy memoryRetentionPolicy() {\n        return RetentionPolicy.builder()\n            .episodicMemoryRetention(Duration.ofDays(30))\n            .vectorMemoryRetention(Duration.ofDays(90))\n            .build();\n    }\n}\n</code></pre>"},{"location":"09%20-%20Privacy%20%26%20Governance.html#compliance-features","title":"Compliance Features","text":"<ol> <li>Data Isolation</li> <li>Tenant-based memory isolation</li> <li>Subsystem-level access control</li> <li> <p>Cross-tenant data protection</p> </li> <li> <p>Audit Trail</p> </li> <li>Memory operation logging</li> <li>Access pattern tracking</li> <li> <p>Compliance reporting</p> </li> <li> <p>Data Retention</p> </li> <li>Configurable retention periods</li> <li>Automated data cleanup</li> <li>Retention policy enforcement</li> </ol>"},{"location":"09%20-%20Privacy%20%26%20Governance.html#testing-privacy-controls","title":"Testing Privacy Controls","text":"<pre><code>@Test\nvoid testMemoryPrivacy() {\n    PrivacyConfig config = new PrivacyConfig(true, true, true);\n    MemoryManager manager = new MemoryManager(memories, strategies, config);\n\n    // Test data isolation\n    assertFalse(manager.canAccessMemory(\"tenant1\", \"tenant2\"));\n\n    // Test audit logging\n    verify(auditLogger).logMemoryOperation(\n        eq(\"store\"),\n        eq(\"tenant1\"),\n        eq(MemorySubsystem.EPISODIC),\n        any(Message.class)\n    );\n}\n</code></pre>"},{"location":"10%20-%20Extending%20Minions.html","title":"Extending Minions","text":"<p>Minions is modular. You can extend it by:</p> <ul> <li>Creating new <code>Step</code>, <code>Tool</code>, <code>Processor</code>, or <code>MemoryStrategy</code></li> <li>Defining new transition strategies</li> <li>Injecting custom evaluators, observers, filters</li> <li>Composing new <code>AgentRecipe</code> classes</li> </ul>"},{"location":"11%20-%20Examples.html","title":"Examples","text":"<ul> <li>ReAct Agent with Memory and Tools: A reasoning agent that reads from memory and calls external APIs.</li> <li>Planner with Conditional Branching: Plan, act, and re-evaluate based on tool outcomes.</li> <li>Privacy-Aware Agent: Uses filters to redact user PII before prompting the model.</li> </ul>"},{"location":"12%20-%20Testing%20%26%20Debugging.html","title":"Testing &amp; Debugging","text":""},{"location":"12%20-%20Testing%20%26%20Debugging.html#unit-testing","title":"Unit Testing","text":""},{"location":"12%20-%20Testing%20%26%20Debugging.html#testing-memory-components","title":"Testing Memory Components","text":""},{"location":"12%20-%20Testing%20%26%20Debugging.html#testing-memory-query-strategies","title":"Testing Memory Query Strategies","text":"<pre><code>@ExtendWith(MockitoExtension.class)\nclass StepVectorQueryStrategyTest {\n    @Mock\n    private StepContext stepContext;\n\n    @BeforeEach\n    void setUp() {\n        strategy = new StepVectorQueryStrategy();\n    }\n\n    @Test\n    void testGetMemoryQueryReturnsValidQuery() {\n        MemoryQuery query = strategy.getMemoryQuery(stepContext);\n        assertNotNull(query);\n        assertNotNull(query.getExpression());\n    }\n\n    @Test\n    void testAcceptsStepContext() {\n        assertTrue(strategy.accepts(stepContext));\n        assertFalse(strategy.accepts(mock(ProcessContext.class)));\n    }\n}\n</code></pre>"},{"location":"12%20-%20Testing%20%26%20Debugging.html#testing-memory-summarization","title":"Testing Memory Summarization","text":"<pre><code>@ExtendWith(MockitoExtension.class)\nclass MemorySummarizerProcessorTest {\n    @Mock\n    private AgentContext agentContext;\n    @Mock\n    private MemoryManager memoryManager;\n    @Mock\n    private ModelCallService modelCallService;\n\n    @BeforeEach\n    void setUp() {\n        processor = new MemorySummarizerProcessor(modelCallService);\n        when(agentContext.getMemoryManager()).thenReturn(memoryManager);\n    }\n\n    @Test\n    void testDoProcessQueriesMemoryAndStoresMessages() {\n        List&lt;Message&gt; memoryMessages = List.of(message1, message2);\n        when(memoryManager.query(any(MemoryQuery.class))).thenReturn(memoryMessages);\n\n        processor.process(agentContext);\n\n        verify(memoryManager).query(any(MemoryQuery.class));\n        verify(memoryManager).storeAll(anyList(), eq(MemorySubsystem.EPISODIC));\n        verify(memoryManager).storeAll(anyList(), eq(MemorySubsystem.VECTOR));\n    }\n}\n</code></pre>"},{"location":"12%20-%20Testing%20%26%20Debugging.html#testing-memory-persistence","title":"Testing Memory Persistence","text":"<pre><code>@Test\nvoid testPostgresPersistence() {\n    PersistenceStrategy strategy = new PostgresPersistenceStrategy(dataSource);\n    Message message = createTestMessage();\n\n    strategy.store(message);\n    Message retrieved = strategy.retrieve(message.getId());\n\n    assertEquals(message.getId(), retrieved.getId());\n    assertEquals(message.getContent(), retrieved.getContent());\n}\n</code></pre>"},{"location":"12%20-%20Testing%20%26%20Debugging.html#integration-testing","title":"Integration Testing","text":""},{"location":"12%20-%20Testing%20%26%20Debugging.html#testing-memory-chain","title":"Testing Memory Chain","text":"<pre><code>@Test\nvoid testMemoryChain() {\n    MemoryManager manager = new MemoryManager(memories, queryStrategies);\n    Message message = createTestMessage();\n\n    manager.store(MemorySubsystem.EPISODIC, message);\n    Message retrieved = manager.retrieve(message.getId());\n\n    assertNotNull(retrieved);\n    assertEquals(message.getId(), retrieved.getId());\n}\n</code></pre>"},{"location":"12%20-%20Testing%20%26%20Debugging.html#debugging-memory-issues","title":"Debugging Memory Issues","text":"<ol> <li>Memory Query Issues:</li> <li>Check query expressions</li> <li>Verify memory subsystem configuration</li> <li> <p>Inspect query strategy selection</p> </li> <li> <p>Summarization Issues:</p> </li> <li>Verify model call configuration</li> <li>Check input message limits</li> <li> <p>Inspect summary storage</p> </li> <li> <p>Persistence Issues:</p> </li> <li>Check database connectivity</li> <li>Verify schema configuration</li> <li>Inspect transaction handling</li> </ol>"},{"location":"13%20-%20Roadmap%20%26%20Contribution.html","title":"Roadmap & Contribution","text":"<ul> <li>Support for Google A2A multi-agent protocol</li> <li>Visual step graph debugger</li> <li>RAG-native agent types</li> <li>Python bridge (interop with LangChain tools)</li> <li>Contributions welcome via GitHub</li> </ul>"}]}