{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Minions Framework","text":"<p>Minions is an extensible, MCP-compliant agentic AI framework written in Java and built using idiomatic Spring practices. Designed from the ground up with the principles of extensibility, traceability, and enterprise readiness, Minions provides a solid foundation for building and orchestrating autonomous AI agents in regulated and complex environments.</p> <p>At its core, Minions follows the Open/Closed Principle: the system is open for extension but closed for modification. Whether you're building a ReAct-style reasoning agent, a planner-executor-observer pipeline, or a bespoke recipe for your enterprise workflow, Minions enables it without changing the underlying framework.</p>"},{"location":"index.html#why-minions","title":"Why Minions?","text":"<p>The AI ecosystem has rapidly shifted toward agentic workflows\u2014systems where autonomous agents reason, plan, act, and reflect over multiple steps. While many open-source frameworks offer this in Python, Minions is one of the few that brings this capability to the enterprise Java ecosystem with full support for:</p> <ul> <li>Spring Boot auto-configuration and injection</li> <li>Modular architecture that can be expanded with Spring Beans</li> <li>Privacy and governance by design</li> <li>Idiomatic support for lifecycle management, configuration, and testing</li> <li>Multi-tiered memory architecture with pluggable strategies for querying, persisting, retrieving and flusing the memory modules</li> <li>Enterprise-grade persistence through integration with Spring Data</li> </ul>"},{"location":"index.html#key-design-principles","title":"Key Design Principles","text":"<ul> <li> <p>Extensibility First   Minions uses design patterns like Definition/Customizer, Chain of Responsibility, and Factory Registry to allow seamless plug-in of new components\u2014steps, tools, memories, processors\u2014without modifying the core.</p> </li> <li> <p>Idiomatic Spring Integration   The framework follows familiar Spring idioms, making it easy for developers to inject, override, and extend functionality using standard annotations and configuration mechanisms.</p> </li> <li> <p>MCP Compliance   Minions adheres to the Model Connector Protocol (MCP), enabling composability, cross-model interoperability, and architectural clarity.</p> </li> <li> <p>Enterprise-Grade Capabilities   Features like memory privacy, audit hooks, multi-tenant memory isolation, and structured evaluation make Minions a suitable foundation for regulated industries like insurance, healthcare, and finance.</p> </li> </ul>"},{"location":"index.html#memory-architecture","title":"Memory Architecture","text":"<p>Minions implements a sophisticated multi-tiered memory system:</p> <ul> <li>Episodic Memory: Chronological event storage</li> <li>Vector Memory: Semantic similarity search</li> <li>Short-Term Memory: Active context management</li> <li>Long-Term Memory: Persistent knowledge storage</li> </ul> <p>Each memory subsystem is managed through pluggable strategies for: - Query execution - Persistence - Summarization - Privacy and governance</p>"},{"location":"index.html#agent-recipes","title":"Agent Recipes","text":"<p>Every agent in Minions is instantiated from a Recipe. A recipe defines the agent's purpose and structure:</p> <ul> <li>Its system prompt and goal</li> <li>The step graph that outlines its thought/action flow</li> <li>Its memory configuration, specifying:</li> <li>Memory subsystem selection</li> <li>Query strategy configuration</li> <li>Summarization settings</li> <li>Persistence strategy</li> <li>Optional toolchains and observers</li> </ul> <p>Different types of recipes are available out-of-the-box, including: - <code>ReActAgentRecipe</code> - <code>PlannerExecutorObserverRecipe</code> - And more custom agent types</p> <p>We'll dive deeper into recipes, step graphs, and memory strategies in the following sections.</p>"},{"location":"01%20-%20Core%20Concepts.html","title":"Core Concepts","text":"<p>Understanding the foundational elements of Minions is essential before diving into its deeper architecture. This section introduces the two most important constructs: Agents and Recipes.</p>"},{"location":"01%20-%20Core%20Concepts.html#what-is-an-agent","title":"What is an Agent?","text":"<p>In Minions, an Agent is an autonomous entity capable of executing a goal-driven process. It engages in multi-step reasoning, decision-making, and tool interaction. Each agent operates within a defined context, maintaining state across steps and coordinating its behavior using recipes, memory, and step graphs.</p>"},{"location":"01%20-%20Core%20Concepts.html#agent-lifecycle","title":"Agent Lifecycle","text":"<ol> <li> <p>Initialization: The agent is instantiated from a recipe. This includes loading its system prompt, goal, memory configuration, and step graph.</p> </li> <li> <p>Goal Assignment: A goal is defined either at instantiation or injected dynamically (e.g., from user input or a higher-level planner).</p> </li> <li> <p>Step Execution: The agent traverses its step graph, making decisions, calling models, and interacting with tools as needed.</p> </li> <li> <p>Memory Management: The agent maintains multiple memory subsystems:</p> <ul> <li>Episodic memory for chronological event storage</li> <li>Vector memory for semantic similarity search</li> <li>Short-term memory for active context</li> <li>Long-term memory for persistent knowledge</li> </ul> </li> <li> <p>Memory Summarization: After each step, the agent:</p> <ul> <li>Queries relevant memory based on context</li> <li>Generates summaries using model calls</li> <li>Updates appropriate memory subsystems</li> <li>Maintains memory efficiency through summarization</li> </ul> </li> <li> <p>Completion: The agent completes once the graph reaches a terminal node or a completion condition is met.</p> </li> </ol> <p>Agents are MCP-compliant and traceable, allowing developers to monitor execution, review decision points, and integrate with observability tooling.</p>"},{"location":"01%20-%20Core%20Concepts.html#what-is-a-recipe","title":"What is a Recipe?","text":"<p>A Recipe is a declarative blueprint for constructing an agent. Rather than configuring agents imperatively through code, developers define recipes that describe the agent's identity, structure, and behavior.</p> <p>A recipe includes:</p> <ul> <li> <p>System Prompt \u2013 The initial set of instructions or framing context for the agent's behavior.</p> </li> <li> <p>Goal \u2013 The task or objective the agent is trying to achieve.</p> </li> <li> <p>Step Graph \u2013 A flow structure of logical steps the agent executes in order, conditionally, or iteratively.</p> </li> <li> <p>Memory Configuration \u2013 Defines how the agent manages memory:</p> <ul> <li>Memory subsystem selection and configuration</li> <li>Query strategy configuration</li> <li>Summarization settings</li> <li>Persistence strategy selection</li> </ul> </li> <li> <p>Toolchain and Hooks (optional) \u2013 Tools the agent can call and hooks for evaluation, logging, or transformation.</p> </li> </ul> <p>By encapsulating these into a recipe, Minions makes it easy to spin up different kinds of agents, each purpose-built for a use case, without rewriting orchestration logic.</p>"},{"location":"02%20-%20Step%20Graph.html","title":"Step Graph","text":"<p>A Step Graph defines the structured flow of logic an agent follows to reach its goal. Unlike ad hoc prompt chaining, Minions formalizes execution paths using a graph of steps connected by transitions.</p>"},{"location":"02%20-%20Step%20Graph.html#components","title":"Components","text":"<ul> <li>Step: A unit of logic or decision. A step can:</li> <li>Invoke a model</li> <li>Execute a tool call</li> <li>Query or update memory</li> <li>Make a transition decision</li> <li>StepGraphDefinition: Declarative definition of steps and their transitions</li> <li>TransitionStrategy: Defines how the agent determines the next step</li> <li>Sequential transitions</li> <li>Conditional transitions</li> <li>Dynamic transitions based on memory state</li> <li>Start Step / Terminal Step: Every graph has an entry point and can define one or more terminal states</li> </ul>"},{"location":"02%20-%20Step%20Graph.html#memory-aware-steps","title":"Memory-Aware Steps","text":"<p>Steps can interact with memory subsystems:</p> <pre><code>@Component\npublic class MemoryAwareStep implements Step {\n    private final MemoryManager memoryManager;\n\n    @Override\n    public StepResult execute(StepContext context) {\n        // Query memory\n        List&lt;Message&gt; memory = memoryManager.query(context);\n\n        // Store results\n        memoryManager.store(MemorySubsystem.EPISODIC, result);\n\n        return StepResult.builder()\n            .outcome(StepCompletionOutcome.COMPLETE)\n            .build();\n    }\n}\n</code></pre>"},{"location":"02%20-%20Step%20Graph.html#step-execution-flow","title":"Step Execution Flow","text":"<ol> <li>Agent starts at the defined start step</li> <li>Executes step logic:</li> <li>Prompts the model</li> <li>Triggers a tool</li> <li>Queries memory subsystems</li> <li>Processes memory results</li> <li>Determines the next step using a transition strategy</li> <li>Repeats until a terminal step is reached or a completion condition is satisfied</li> </ol>"},{"location":"02%20-%20Step%20Graph.html#memory-integration","title":"Memory Integration","text":"<p>Steps can integrate with memory in several ways:</p> <ol> <li>Memory Query</li> </ol> <pre><code>MemoryQuery query = MemoryQuery.builder()\n    .expression(Expr.eq(\"conversationId\", context.getConversationId()))\n    .limit(10)\n    .build();\nList&lt;Message&gt; results = memoryManager.query(query);\n</code></pre> <ol> <li>Memory Storage</li> </ol> <pre><code>memoryManager.store(MemorySubsystem.EPISODIC, message);\nmemoryManager.store(MemorySubsystem.VECTOR, message);\n</code></pre> <ol> <li>Memory Summarization</li> </ol> <pre><code>@Autowired\nprivate MemorySummarizerProcessor summarizer;\n\npublic StepResult execute(StepContext context) {\n    summarizer.process(context);\n    // Continue with step logic\n}\n</code></pre>"},{"location":"02%20-%20Step%20Graph.html#customizing-step-graphs","title":"Customizing Step Graphs","text":"<p>Minions supports a Definition/Customizer pattern:</p> <ul> <li>Definition defines the logic and structure</li> <li>Customizers allow injection of additional behavior:</li> <li>Memory query strategies</li> <li>Memory summarization rules</li> <li>Persistence configurations</li> <li>Transitions based on memory state</li> </ul> <p>This allows default agent flows to be extended in context-aware ways\u2014e.g., adding memory-aware retry steps or custom memory processing logic.</p>"},{"location":"03%20-%20Memory%20Management.html","title":"Memory Management","text":"<p>Memory is a first-class concept in Minions. It gives agents the ability to remember context, recall facts, and summarize experiences across steps.</p>"},{"location":"03%20-%20Memory%20Management.html#memory-subsystems","title":"Memory Subsystems","text":"<p>Minions implements a multi-tiered memory architecture:</p> <ul> <li>Episodic Memory: Stores sequences of events and experiences in chronological order</li> <li>Vector Memory: Stores semantic representations of messages for similarity-based retrieval</li> <li>Short-Term Memory: Maintains recent context and active working memory</li> <li>Long-Term Memory: Stores persistent knowledge and facts across conversations</li> </ul>"},{"location":"03%20-%20Memory%20Management.html#memory-query-strategies","title":"Memory Query Strategies","text":"<p>Memory querying is implemented through pluggable strategies that determine how to retrieve information:</p>"},{"location":"03%20-%20Memory%20Management.html#step-based-strategies","title":"Step-based Strategies","text":"<ul> <li>StepVectorQueryStrategy: Handles vector-based queries within step context</li> <li>StepShortTermQueryStrategy: Manages short-term memory queries for steps</li> <li>StepEntityQueryStrategy: Handles entity-based queries within step context</li> </ul>"},{"location":"03%20-%20Memory%20Management.html#agent-based-strategies","title":"Agent-based Strategies","text":"<ul> <li>AgentVectorQueryStrategy: Manages vector-based queries at agent level</li> <li>AgentShortTermQueryStrategy: Handles short-term memory queries for agents</li> <li>AgentLongTermQueryStrategy: Manages long-term memory queries for agents</li> <li>AgentEntityQueryStrategy: Handles entity-based queries at agent level</li> </ul>"},{"location":"03%20-%20Memory%20Management.html#memory-operations","title":"Memory Operations","text":"<p>The <code>MemoryManager</code> coordinates memory operations across subsystems:</p> <pre><code>// Store messages in specific memory subsystem\nmemoryManager.store(MemorySubsystem.EPISODIC, message);\n\n// Query memory using DSL\nMemoryQuery query = MemoryQuery.builder()\n    .expression(Expr.eq(\"conversationId\", \"C1\"))\n    .limit(10)\n    .build();\nList&lt;Message&gt; results = memoryManager.query(query);\n\n// Retrieve specific message\nMessage message = memoryManager.retrieve(\"messageId\");\n\n// Flush memory\nmemoryManager.flush();\n</code></pre>"},{"location":"03%20-%20Memory%20Management.html#memory-persistence","title":"Memory Persistence","text":"<p>Memory persistence is handled through pluggable strategies:</p> <ul> <li>InMemoryPersistence: Default strategy for development and testing</li> <li>PostgresPersistence: Production-ready persistence using PostgreSQL</li> <li>Custom Persistence: Implement <code>PersistenceStrategy</code> for custom storage</li> </ul>"},{"location":"03%20-%20Memory%20Management.html#memory-summarization","title":"Memory Summarization","text":"<p>The <code>MemorySummarizerProcessor</code> handles memory summarization:</p> <ol> <li>Queries relevant memory based on conversation context</li> <li>Uses model calls to generate summaries</li> <li>Stores summaries in appropriate memory subsystems</li> <li>Maintains memory efficiency by condensing older information</li> </ol>"},{"location":"03%20-%20Memory%20Management.html#configuration","title":"Configuration","text":"<p>Memory behavior is configured through:</p> <pre><code>SummarizationConfig config = SummarizationConfig.builder()\n    .inputMessageLimit(10)\n    .modelConfig(modelConfig)\n    .build();\n</code></pre> <p>This allows fine-tuning of: - Message limits for summarization - Model selection for summarization - Memory subsystem behavior - Query strategy selection</p>"},{"location":"04%20-%20Process%20Chains.html","title":"Process Chains","text":"<p>Minions uses the Chain of Responsibility pattern to handle agent behaviors in a modular way. This pattern allows for flexible composition of behaviors and easy extension of functionality.</p>"},{"location":"04%20-%20Process%20Chains.html#chains-are-used-in","title":"Chains are used in:","text":"<ul> <li>Step Completion Evaluation</li> <li>Memory Management</li> <li>Memory Summarization</li> <li>Memory Query Execution</li> <li>Memory Persistence</li> <li>Tool Selection</li> <li>Custom Output Evaluation</li> </ul> <p>Each chain is made of <code>Processor&lt;T extends ProcessContext&gt;</code> implementations that can be prioritized and conditionally applied.</p>"},{"location":"04%20-%20Process%20Chains.html#memory-processors","title":"Memory Processors","text":""},{"location":"04%20-%20Process%20Chains.html#memory-summarizer-processor","title":"Memory Summarizer Processor","text":"<pre><code>@Component\npublic class MemorySummarizerProcessor implements Processor&lt;AgentContext&gt; {\n    private final ModelCallService modelCallService;\n\n    @Override\n    public AgentContext process(AgentContext input) {\n        // Query memory based on context\n        // Generate summaries using model calls\n        // Store summaries in appropriate subsystems\n        return input;\n    }\n}\n</code></pre>"},{"location":"04%20-%20Process%20Chains.html#memory-query-processors","title":"Memory Query Processors","text":"<pre><code>@Component\npublic class StepVectorQueryStrategy implements MemoryQueryStrategy {\n    @Override\n    public MemoryQuery getMemoryQuery(ProcessContext context) {\n        // Build and return memory query\n    }\n\n    @Override\n    public List&lt;MemorySubsystem&gt; getSupportedSubsystem() {\n        return List.of(MemorySubsystem.VECTOR);\n    }\n}\n</code></pre>"},{"location":"04%20-%20Process%20Chains.html#defining-a-processor","title":"Defining a Processor","text":"<pre><code>@Component\npublic class MaxModelCallCountProcessor\n        extends AbstractProcessor&lt;StepGraphCompletionContext&lt;ProcessResult&lt;StepCompletionOutcome&gt;&gt;, StepCompletionOutcome&gt; {\n\n    @Override\n    public StepCompletionOutcome doProcess(StepGraphCompletionContext input) {\n        // Custom logic\n    }\n}\n</code></pre>"},{"location":"04%20-%20Process%20Chains.html#processor-configuration","title":"Processor Configuration","text":"<p>Processors can be configured through:</p> <ol> <li>Spring Configuration</li> </ol> <pre><code>@Configuration\npublic class ProcessorConfig {\n    @Bean\n    public Processor&lt;AgentContext&gt; memorySummarizerProcessor(ModelCallService modelCallService) {\n        return new MemorySummarizerProcessor(modelCallService);\n    }\n}\n</code></pre> <ol> <li>Customizers</li> </ol> <pre><code>@Component\npublic class MemoryProcessorCustomizer implements ProcessorCustomizer&lt;MemorySummarizerProcessor&gt; {\n    @Override\n    public void customize(MemorySummarizerProcessor processor) {\n        // Custom configuration\n    }\n}\n</code></pre>"},{"location":"04%20-%20Process%20Chains.html#testing-processors","title":"Testing Processors","text":"<pre><code>@ExtendWith(MockitoExtension.class)\nclass MemorySummarizerProcessorTest {\n    @Mock\n    private AgentContext context;\n    @Mock\n    private ModelCallService modelCallService;\n\n    @Test\n    void testProcess() {\n        MemorySummarizerProcessor processor = new MemorySummarizerProcessor(modelCallService);\n        AgentContext result = processor.process(context);\n        // Verify behavior\n    }\n}\n</code></pre> <p>Processors can expose Customizers to inject logic conditionally during Spring bootstrapping.</p>"},{"location":"05%20-%20Tool%20Integration.html","title":"Tool Integration","text":"<p>Agents often rely on tools to gather data, make external API calls, or trigger workflows. Tools can also interact with memory subsystems to store and retrieve information.</p>"},{"location":"05%20-%20Tool%20Integration.html#defining-a-tool","title":"Defining a Tool","text":"<p>A tool is a Spring Bean implementing <code>Tool&lt;TInput, TOutput&gt;</code>. It must define:</p> <ul> <li>The name and input schema</li> <li>Execution logic (usually async)</li> <li>Optionally: tool metadata and dynamic arguments</li> <li>Memory integration points</li> </ul>"},{"location":"05%20-%20Tool%20Integration.html#memory-aware-tools","title":"Memory-Aware Tools","text":"<p>Tools can interact with memory subsystems:</p> <pre><code>@Component\npublic class MemoryAwareTool implements Tool&lt;ToolInput, ToolOutput&gt; {\n    private final MemoryManager memoryManager;\n\n    @Override\n    public ToolOutput execute(ToolInput input) {\n        // Query memory for context\n        List&lt;Message&gt; context = memoryManager.query(input.getContext());\n\n        // Execute tool logic\n        ToolOutput output = process(input, context);\n\n        // Store results in memory\n        memoryManager.store(MemorySubsystem.EPISODIC, output.toMessage());\n\n        return output;\n    }\n}\n</code></pre>"},{"location":"05%20-%20Tool%20Integration.html#tool-usage-flow","title":"Tool Usage Flow","text":"<ol> <li>Step issues a tool call request</li> <li>Tool resolves parameters and executes logic:</li> <li>Queries memory for context</li> <li>Performs tool-specific operations</li> <li>Stores results in memory</li> <li>Output is passed to the agent and can be:</li> <li>Stored in memory subsystems</li> <li>Used for reasoning</li> <li>Summarized for long-term storage</li> </ol>"},{"location":"05%20-%20Tool%20Integration.html#memory-integration-points","title":"Memory Integration Points","text":"<p>Tools can integrate with memory at several points:</p> <ol> <li>Pre-execution</li> </ol> <pre><code>// Query memory for context\nMemoryQuery query = MemoryQuery.builder()\n    .expression(Expr.eq(\"toolId\", toolId))\n    .limit(5)\n    .build();\nList&lt;Message&gt; context = memoryManager.query(query);\n</code></pre> <ol> <li>Post-execution</li> </ol> <pre><code>// Store tool results\nMessage result = Message.builder()\n    .content(output.toString())\n    .metadata(\"toolId\", toolId)\n    .build();\nmemoryManager.store(MemorySubsystem.EPISODIC, result);\n</code></pre> <ol> <li>Error Handling</li> </ol> <pre><code>try {\n    return execute(input);\n} catch (Exception e) {\n    // Store error in memory\n    Message error = Message.builder()\n        .content(e.getMessage())\n        .metadata(\"error\", true)\n        .build();\n    memoryManager.store(MemorySubsystem.EPISODIC, error);\n    throw e;\n}\n</code></pre>"},{"location":"05%20-%20Tool%20Integration.html#testing-tools","title":"Testing Tools","text":"<pre><code>@ExtendWith(MockitoExtension.class)\nclass MemoryAwareToolTest {\n    @Mock\n    private MemoryManager memoryManager;\n\n    @Test\n    void testExecute() {\n        MemoryAwareTool tool = new MemoryAwareTool(memoryManager);\n        ToolInput input = createTestInput();\n\n        when(memoryManager.query(any())).thenReturn(List.of());\n        ToolOutput output = tool.execute(input);\n\n        verify(memoryManager).query(any());\n        verify(memoryManager).store(eq(MemorySubsystem.EPISODIC), any());\n        assertNotNull(output);\n    }\n}\n</code></pre>"},{"location":"06%20-%20MCP%20Compliance.html","title":"MCP Compliance","text":"<p>Minions adheres to the Model Connector Protocol (MCP), ensuring compatibility with other MCP-compliant systems and tools.</p>"},{"location":"06%20-%20MCP%20Compliance.html#memory-compliance","title":"Memory Compliance","text":""},{"location":"06%20-%20MCP%20Compliance.html#memory-operations","title":"Memory Operations","text":"<p>All memory operations follow MCP specifications:</p> <pre><code>// MCP-compliant memory query\nMemoryQuery query = MemoryQuery.builder()\n    .expression(Expr.mcp(\"conversationId\", \"C1\"))\n    .limit(10)\n    .build();\n\n// MCP-compliant memory storage\nMessage message = Message.builder()\n    .content(\"content\")\n    .metadata(\"mcp:type\", \"user_message\")\n    .build();\n</code></pre>"},{"location":"06%20-%20MCP%20Compliance.html#memory-subsystems","title":"Memory Subsystems","text":"<p>Each memory subsystem implements MCP interfaces:</p> <pre><code>public class EpisodicMemory implements Memory&lt;MemoryContext, Message&gt;, McpCompliant {\n    @Override\n    public McpMetadata getMcpMetadata() {\n        return McpMetadata.builder()\n            .type(\"episodic\")\n            .version(\"1.0\")\n            .build();\n    }\n}\n</code></pre>"},{"location":"06%20-%20MCP%20Compliance.html#compliance-requirements","title":"Compliance Requirements","text":"<ol> <li>Memory Operations</li> <li>All memory queries must use MCP-compliant expressions</li> <li>Memory storage must include MCP metadata</li> <li> <p>Memory retrieval must respect MCP limits</p> </li> <li> <p>Memory Subsystems</p> </li> <li>Each subsystem must implement McpCompliant interface</li> <li>Subsystems must provide MCP metadata</li> <li> <p>Subsystems must handle MCP-specific operations</p> </li> <li> <p>Memory Persistence</p> </li> <li>Persistence strategies must store MCP metadata</li> <li>Data formats must follow MCP specifications</li> <li>Query languages must support MCP expressions</li> </ol>"},{"location":"06%20-%20MCP%20Compliance.html#testing-compliance","title":"Testing Compliance","text":"<pre><code>@Test\nvoid testMcpCompliance() {\n    MemoryManager manager = new MemoryManager(memories, strategies);\n\n    // Test MCP-compliant query\n    MemoryQuery query = createMcpQuery();\n    List&lt;Message&gt; results = manager.query(query);\n    assertMcpCompliant(results);\n\n    // Test MCP-compliant storage\n    Message message = createMcpMessage();\n    manager.store(MemorySubsystem.EPISODIC, message);\n    assertMcpCompliant(message);\n}\n</code></pre>"},{"location":"07%20-%20Spring%20Integration.html","title":"Spring Integration","text":"<p>Minions is built on Spring Boot, making it easy to integrate with existing Spring applications and leverage Spring's dependency injection and configuration capabilities.</p>"},{"location":"07%20-%20Spring%20Integration.html#memory-configuration","title":"Memory Configuration","text":""},{"location":"07%20-%20Spring%20Integration.html#memory-subsystems","title":"Memory Subsystems","text":"<pre><code>@Configuration\npublic class MemoryConfig {\n    @Bean\n    public Memory&lt;MemoryContext, Message&gt; episodicMemory() {\n        return new EpisodicMemory();\n    }\n\n    @Bean\n    public Memory&lt;MemoryContext, Message&gt; vectorMemory() {\n        return new VectorMemory();\n    }\n\n    @Bean\n    public MemoryManager memoryManager(\n            List&lt;Memory&lt;MemoryContext, Message&gt;&gt; memories,\n            List&lt;MemoryQueryStrategy&gt; strategies) {\n        return new MemoryManager(memories, strategies);\n    }\n}\n</code></pre>"},{"location":"07%20-%20Spring%20Integration.html#query-strategies","title":"Query Strategies","text":"<pre><code>@Configuration\npublic class QueryStrategyConfig {\n    @Bean\n    public MemoryQueryStrategy stepVectorQueryStrategy() {\n        return new StepVectorQueryStrategy();\n    }\n\n    @Bean\n    public MemoryQueryStrategy agentLongTermQueryStrategy() {\n        return new AgentLongTermQueryStrategy();\n    }\n}\n</code></pre>"},{"location":"07%20-%20Spring%20Integration.html#persistence-configuration","title":"Persistence Configuration","text":"<pre><code>@Configuration\npublic class PersistenceConfig {\n    @Bean\n    public PersistenceStrategy postgresPersistenceStrategy(DataSource dataSource) {\n        return new PostgresPersistenceStrategy(dataSource);\n    }\n}\n</code></pre>"},{"location":"07%20-%20Spring%20Integration.html#auto-configuration","title":"Auto-Configuration","text":"<p>Minions provides auto-configuration for common components:</p> <pre><code>@Configuration\n@ConditionalOnProperty(name = \"minions.memory.enabled\", havingValue = \"true\")\npublic class MemoryAutoConfiguration {\n    @Bean\n    @ConditionalOnMissingBean\n    public MemoryManager memoryManager() {\n        // Default configuration\n    }\n}\n</code></pre>"},{"location":"07%20-%20Spring%20Integration.html#custom-configuration","title":"Custom Configuration","text":"<p>Override default configurations using Spring properties:</p> <pre><code>minions:\n  memory:\n    enabled: true\n    subsystems:\n      episodic:\n        enabled: true\n      vector:\n        enabled: true\n    persistence:\n      type: postgres\n      schema: minions\n</code></pre>"},{"location":"07%20-%20Spring%20Integration.html#testing-support","title":"Testing Support","text":"<p>Spring provides testing utilities for memory components:</p> <pre><code>@SpringBootTest\nclass MemoryIntegrationTest {\n    @Autowired\n    private MemoryManager memoryManager;\n\n    @Test\n    void testMemoryOperations() {\n        // Test memory operations\n    }\n}\n</code></pre> <p>Minions is built around idiomatic Spring patterns:</p> <ul> <li>Use <code>@Component</code> to register custom steps, processors, tools, strategies</li> <li><code>@ConfigurationProperties</code> for loading recipe or agent configuration from YAML or application context</li> <li>Conditional wiring using Spring Boot's auto-config features</li> </ul> <p>You can fully extend Minions without modifying its internals, using standard Spring idioms.</p>"},{"location":"08%20-%20Evaluation%20%26%20Observability.html","title":"Evaluation &amp; Observability","text":"<p>Minions provides comprehensive evaluation and observability features, including memory-specific metrics and monitoring capabilities.</p>"},{"location":"08%20-%20Evaluation%20%26%20Observability.html#memory-metrics","title":"Memory Metrics","text":""},{"location":"08%20-%20Evaluation%20%26%20Observability.html#performance-metrics","title":"Performance Metrics","text":"<pre><code>@Component\npublic class MemoryMetrics {\n    private final MeterRegistry registry;\n\n    public void recordMemoryOperation(\n            String operation,\n            MemorySubsystem subsystem,\n            long duration) {\n        registry.timer(\"memory.operation\", \n            \"operation\", operation,\n            \"subsystem\", subsystem.name())\n            .record(duration, TimeUnit.MILLISECONDS);\n    }\n}\n</code></pre>"},{"location":"08%20-%20Evaluation%20%26%20Observability.html#memory-health","title":"Memory Health","text":"<pre><code>@Component\npublic class MemoryHealthIndicator implements HealthIndicator {\n    private final MemoryManager memoryManager;\n\n    @Override\n    public Health health() {\n        return Health.builder()\n            .withDetail(\"episodic\", checkSubsystem(MemorySubsystem.EPISODIC))\n            .withDetail(\"vector\", checkSubsystem(MemorySubsystem.VECTOR))\n            .build();\n    }\n}\n</code></pre>"},{"location":"08%20-%20Evaluation%20%26%20Observability.html#memory-monitoring","title":"Memory Monitoring","text":""},{"location":"08%20-%20Evaluation%20%26%20Observability.html#query-monitoring","title":"Query Monitoring","text":"<pre><code>@Aspect\n@Component\npublic class MemoryQueryMonitor {\n    @Around(\"execution(* com.minionslab.core.memory.MemoryManager.query(..))\")\n    public Object monitorQuery(ProceedingJoinPoint pjp) {\n        // Monitor query performance\n        // Track query patterns\n        // Alert on anomalies\n    }\n}\n</code></pre>"},{"location":"08%20-%20Evaluation%20%26%20Observability.html#storage-monitoring","title":"Storage Monitoring","text":"<pre><code>@Aspect\n@Component\npublic class MemoryStorageMonitor {\n    @Around(\"execution(* com.minionslab.core.memory.MemoryManager.store(..))\")\n    public Object monitorStorage(ProceedingJoinPoint pjp) {\n        // Monitor storage operations\n        // Track storage patterns\n        // Alert on capacity issues\n    }\n}\n</code></pre>"},{"location":"08%20-%20Evaluation%20%26%20Observability.html#memory-evaluation","title":"Memory Evaluation","text":""},{"location":"08%20-%20Evaluation%20%26%20Observability.html#query-evaluation","title":"Query Evaluation","text":"<pre><code>@Component\npublic class MemoryQueryEvaluator {\n    public QueryEvaluationResult evaluateQuery(\n            MemoryQuery query,\n            List&lt;Message&gt; results) {\n        return QueryEvaluationResult.builder()\n            .relevance(calculateRelevance(results))\n            .completeness(calculateCompleteness(results))\n            .build();\n    }\n}\n</code></pre>"},{"location":"08%20-%20Evaluation%20%26%20Observability.html#summarization-evaluation","title":"Summarization Evaluation","text":"<pre><code>@Component\npublic class MemorySummarizationEvaluator {\n    public SummarizationEvaluationResult evaluateSummary(\n            List&lt;Message&gt; original,\n            Message summary) {\n        return SummarizationEvaluationResult.builder()\n            .coverage(calculateCoverage(original, summary))\n            .accuracy(calculateAccuracy(original, summary))\n            .build();\n    }\n}\n</code></pre>"},{"location":"08%20-%20Evaluation%20%26%20Observability.html#observability-integration","title":"Observability Integration","text":""},{"location":"08%20-%20Evaluation%20%26%20Observability.html#prometheus-metrics","title":"Prometheus Metrics","text":"<pre><code>management:\n  endpoints:\n    web:\n      exposure:\n        include: health,metrics,prometheus\n  metrics:\n    export:\n      prometheus:\n        enabled: true\n</code></pre>"},{"location":"08%20-%20Evaluation%20%26%20Observability.html#grafana-dashboards","title":"Grafana Dashboards","text":"<pre><code>{\n  \"dashboard\": {\n    \"panels\": [\n      {\n        \"title\": \"Memory Operations\",\n        \"type\": \"graph\",\n        \"targets\": [\n          {\n            \"expr\": \"rate(memory_operation_seconds_count[5m])\",\n            \"legendFormat\": \"{{operation}} - {{subsystem}}\"\n          }\n        ]\n      }\n    ]\n  }\n}\n</code></pre>"},{"location":"08%20-%20Evaluation%20%26%20Observability.html#testing-observability","title":"Testing Observability","text":"<pre><code>@Test\nvoid testMemoryMetrics() {\n    MemoryManager manager = new MemoryManager(memories, strategies);\n    manager.store(MemorySubsystem.EPISODIC, message);\n\n    // Verify metrics\n    assertThat(registry.find(\"memory.operation\")\n        .tag(\"operation\", \"store\")\n        .tag(\"subsystem\", \"EPISODIC\")\n        .timer())\n        .isNotNull();\n}\n</code></pre> <p>Minions supports observability hooks throughout the agent lifecycle:</p> <ul> <li>Step-level evaluations</li> <li>Memory inspection</li> <li>Custom evaluators for response scoring or compliance</li> <li>Audit trails and trace IDs</li> </ul> <p>Observers can be attached declaratively in recipes or dynamically at runtime.</p>"},{"location":"09%20-%20Privacy%20%26%20Governance.html","title":"Privacy &amp; Governance","text":"<p>Minions provides built-in support for privacy and governance requirements, particularly in memory management and data handling.</p>"},{"location":"09%20-%20Privacy%20%26%20Governance.html#memory-privacy","title":"Memory Privacy","text":""},{"location":"09%20-%20Privacy%20%26%20Governance.html#data-isolation","title":"Data Isolation","text":"<p>Memory subsystems support multi-tenant isolation:</p> <pre><code>@Configuration\npublic class MemoryPrivacyConfig {\n    @Bean\n    public MemoryManager memoryManager(\n            List&lt;Memory&lt;MemoryContext, Message&gt;&gt; memories,\n            PrivacyConfig privacyConfig) {\n        return new MemoryManager(memories, strategies, privacyConfig);\n    }\n}\n</code></pre>"},{"location":"09%20-%20Privacy%20%26%20Governance.html#privacy-controls","title":"Privacy Controls","text":"<pre><code>public class PrivacyConfig {\n    private final boolean enableDataIsolation;\n    private final boolean enableAuditLogging;\n    private final boolean enableDataRetention;\n\n    // Privacy controls for memory operations\n    public boolean canAccessMemory(String tenantId, MemorySubsystem subsystem) {\n        // Check access permissions\n    }\n\n    public boolean canStoreData(String tenantId, Message message) {\n        // Check storage permissions\n    }\n}\n</code></pre>"},{"location":"09%20-%20Privacy%20%26%20Governance.html#memory-governance","title":"Memory Governance","text":""},{"location":"09%20-%20Privacy%20%26%20Governance.html#audit-logging","title":"Audit Logging","text":"<p>All memory operations are logged for audit purposes:</p> <pre><code>@Component\npublic class MemoryAuditLogger {\n    public void logMemoryOperation(\n            String operation,\n            String tenantId,\n            MemorySubsystem subsystem,\n            Message message) {\n        // Log memory operation\n    }\n}\n</code></pre>"},{"location":"09%20-%20Privacy%20%26%20Governance.html#data-retention","title":"Data Retention","text":"<p>Memory subsystems support configurable retention policies:</p> <pre><code>@Configuration\npublic class RetentionConfig {\n    @Bean\n    public RetentionPolicy memoryRetentionPolicy() {\n        return RetentionPolicy.builder()\n            .episodicMemoryRetention(Duration.ofDays(30))\n            .vectorMemoryRetention(Duration.ofDays(90))\n            .build();\n    }\n}\n</code></pre>"},{"location":"09%20-%20Privacy%20%26%20Governance.html#compliance-features","title":"Compliance Features","text":"<ol> <li>Data Isolation</li> <li>Tenant-based memory isolation</li> <li>Subsystem-level access control</li> <li> <p>Cross-tenant data protection</p> </li> <li> <p>Audit Trail</p> </li> <li>Memory operation logging</li> <li>Access pattern tracking</li> <li> <p>Compliance reporting</p> </li> <li> <p>Data Retention</p> </li> <li>Configurable retention periods</li> <li>Automated data cleanup</li> <li>Retention policy enforcement</li> </ol>"},{"location":"09%20-%20Privacy%20%26%20Governance.html#testing-privacy-controls","title":"Testing Privacy Controls","text":"<pre><code>@Test\nvoid testMemoryPrivacy() {\n    PrivacyConfig config = new PrivacyConfig(true, true, true);\n    MemoryManager manager = new MemoryManager(memories, strategies, config);\n\n    // Test data isolation\n    assertFalse(manager.canAccessMemory(\"tenant1\", \"tenant2\"));\n\n    // Test audit logging\n    verify(auditLogger).logMemoryOperation(\n        eq(\"store\"),\n        eq(\"tenant1\"),\n        eq(MemorySubsystem.EPISODIC),\n        any(Message.class)\n    );\n}\n</code></pre>"},{"location":"10%20-%20Extending%20Minions.html","title":"Extending Minions","text":"<p>Minions is modular. You can extend it by:</p> <ul> <li>Creating new <code>Step</code>, <code>Tool</code>, <code>Processor</code>, or <code>MemoryStrategy</code></li> <li>Defining new transition strategies</li> <li>Injecting custom evaluators, observers, filters</li> <li>Composing new <code>AgentRecipe</code> classes</li> </ul>"},{"location":"11%20-%20Examples.html","title":"Examples","text":"<ul> <li>ReAct Agent with Memory and Tools: A reasoning agent that reads from memory and calls external APIs.</li> <li>Planner with Conditional Branching: Plan, act, and re-evaluate based on tool outcomes.</li> <li>Privacy-Aware Agent: Uses filters to redact user PII before prompting the model.</li> </ul>"},{"location":"12%20-%20Testing%20%26%20Debugging.html","title":"Testing &amp; Debugging","text":""},{"location":"12%20-%20Testing%20%26%20Debugging.html#unit-testing","title":"Unit Testing","text":""},{"location":"12%20-%20Testing%20%26%20Debugging.html#testing-memory-components","title":"Testing Memory Components","text":""},{"location":"12%20-%20Testing%20%26%20Debugging.html#testing-memory-query-strategies","title":"Testing Memory Query Strategies","text":"<pre><code>@ExtendWith(MockitoExtension.class)\nclass StepVectorQueryStrategyTest {\n    @Mock\n    private StepContext stepContext;\n\n    @BeforeEach\n    void setUp() {\n        strategy = new StepVectorQueryStrategy();\n    }\n\n    @Test\n    void testGetMemoryQueryReturnsValidQuery() {\n        MemoryQuery query = strategy.getMemoryQuery(stepContext);\n        assertNotNull(query);\n        assertNotNull(query.getExpression());\n    }\n\n    @Test\n    void testAcceptsStepContext() {\n        assertTrue(strategy.accepts(stepContext));\n        assertFalse(strategy.accepts(mock(ProcessContext.class)));\n    }\n}\n</code></pre>"},{"location":"12%20-%20Testing%20%26%20Debugging.html#testing-memory-summarization","title":"Testing Memory Summarization","text":"<pre><code>@ExtendWith(MockitoExtension.class)\nclass MemorySummarizerProcessorTest {\n    @Mock\n    private AgentContext agentContext;\n    @Mock\n    private MemoryManager memoryManager;\n    @Mock\n    private ModelCallService modelCallService;\n\n    @BeforeEach\n    void setUp() {\n        processor = new MemorySummarizerProcessor(modelCallService);\n        when(agentContext.getMemoryManager()).thenReturn(memoryManager);\n    }\n\n    @Test\n    void testDoProcessQueriesMemoryAndStoresMessages() {\n        List&lt;Message&gt; memoryMessages = List.of(message1, message2);\n        when(memoryManager.query(any(MemoryQuery.class))).thenReturn(memoryMessages);\n\n        processor.process(agentContext);\n\n        verify(memoryManager).query(any(MemoryQuery.class));\n        verify(memoryManager).storeAll(anyList(), eq(MemorySubsystem.EPISODIC));\n        verify(memoryManager).storeAll(anyList(), eq(MemorySubsystem.VECTOR));\n    }\n}\n</code></pre>"},{"location":"12%20-%20Testing%20%26%20Debugging.html#testing-memory-persistence","title":"Testing Memory Persistence","text":"<pre><code>@Test\nvoid testPostgresPersistence() {\n    PersistenceStrategy strategy = new PostgresPersistenceStrategy(dataSource);\n    Message message = createTestMessage();\n\n    strategy.store(message);\n    Message retrieved = strategy.retrieve(message.getId());\n\n    assertEquals(message.getId(), retrieved.getId());\n    assertEquals(message.getContent(), retrieved.getContent());\n}\n</code></pre>"},{"location":"12%20-%20Testing%20%26%20Debugging.html#integration-testing","title":"Integration Testing","text":""},{"location":"12%20-%20Testing%20%26%20Debugging.html#testing-memory-chain","title":"Testing Memory Chain","text":"<pre><code>@Test\nvoid testMemoryChain() {\n    MemoryManager manager = new MemoryManager(memories, queryStrategies);\n    Message message = createTestMessage();\n\n    manager.store(MemorySubsystem.EPISODIC, message);\n    Message retrieved = manager.retrieve(message.getId());\n\n    assertNotNull(retrieved);\n    assertEquals(message.getId(), retrieved.getId());\n}\n</code></pre>"},{"location":"12%20-%20Testing%20%26%20Debugging.html#debugging-memory-issues","title":"Debugging Memory Issues","text":"<ol> <li>Memory Query Issues:</li> <li>Check query expressions</li> <li>Verify memory subsystem configuration</li> <li> <p>Inspect query strategy selection</p> </li> <li> <p>Summarization Issues:</p> </li> <li>Verify model call configuration</li> <li>Check input message limits</li> <li> <p>Inspect summary storage</p> </li> <li> <p>Persistence Issues:</p> </li> <li>Check database connectivity</li> <li>Verify schema configuration</li> <li>Inspect transaction handling</li> </ol>"},{"location":"13%20-%20Roadmap%20%26%20Contribution.html","title":"Roadmap & Contribution","text":"<ul> <li>Support for Google A2A multi-agent protocol</li> <li>Visual step graph debugger</li> <li>RAG-native agent types</li> <li>Python bridge (interop with LangChain tools)</li> <li>Contributions welcome via GitHub</li> </ul>"}]}